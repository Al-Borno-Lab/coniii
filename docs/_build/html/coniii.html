
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>coniii package &#8212; ConIII 1.0.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="coniii.ising package" href="coniii.ising.html" />
    <link rel="prev" title="Welcome to ConIII’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="coniii-package">
<h1>coniii package<a class="headerlink" href="#coniii-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="coniii.ising.html">coniii.ising package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="coniii.ising.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="coniii.ising.html#module-coniii.ising.automaton">coniii.ising.automaton module</a></li>
<li class="toctree-l2"><a class="reference internal" href="coniii.ising.html#module-coniii.ising.test_automaton">coniii.ising.test_automaton module</a></li>
<li class="toctree-l2"><a class="reference internal" href="coniii.ising.html#module-coniii.ising">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="coniii-custom-maxent-module">
<h2>coniii.custom_maxent module<a class="headerlink" href="#coniii-custom-maxent-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-coniii.enumerate">
<span id="coniii-enumerate-module"></span><h2>coniii.enumerate module<a class="headerlink" href="#module-coniii.enumerate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="coniii.enumerate.add_to_fitterm01">
<code class="descclassname">coniii.enumerate.</code><code class="descname">add_to_fitterm01</code><span class="sig-paren">(</span><em>fitterm</em>, <em>subix</em>, <em>expterm</em>, <em>binstate</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.add_to_fitterm01" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.enumerate.add_to_fitterm11">
<code class="descclassname">coniii.enumerate.</code><code class="descname">add_to_fitterm11</code><span class="sig-paren">(</span><em>fitterm</em>, <em>subix</em>, <em>expterm</em>, <em>binstate</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.add_to_fitterm11" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.enumerate.get_3idx">
<code class="descclassname">coniii.enumerate.</code><code class="descname">get_3idx</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.get_3idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get binary 3D matrix with truth values where index values correspond to the index of all possible ijk
parameters.  We can do this by recognizing that the pattern along each plane in the third dimension is
like the upper triangle pattern that just moves up and over by one block each cut lower into the box.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.get_nidx">
<code class="descclassname">coniii.enumerate.</code><code class="descname">get_nidx</code><span class="sig-paren">(</span><em>k</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.get_nidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the kth order indices corresponding to all the states in which k elements
are firing up out of n spins. The ordering correspond to that returned by
bin_states().</p>
<p>print where(exact.get_3idx(4))
print where(exact.get_nidx(3,4))
&lt;&lt;&lt;&lt;&lt;</p>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.get_terms">
<code class="descclassname">coniii.enumerate.</code><code class="descname">get_terms</code><span class="sig-paren">(</span><em>subix</em>, <em>prefix</em>, <em>binstate</em>, <em>br</em>, <em>ix0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.get_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Spins are put in explicitly</p>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.get_terms01">
<code class="descclassname">coniii.enumerate.</code><code class="descname">get_terms01</code><span class="sig-paren">(</span><em>subix</em>, <em>prefix</em>, <em>binstate</em>, <em>br</em>, <em>ix0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.get_terms01" title="Permalink to this definition">¶</a></dt>
<dd><p>Specific to {0,1}.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.get_terms11">
<code class="descclassname">coniii.enumerate.</code><code class="descname">get_terms11</code><span class="sig-paren">(</span><em>subix</em>, <em>prefix</em>, <em>binstate</em>, <em>br</em>, <em>ix0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.get_terms11" title="Permalink to this definition">¶</a></dt>
<dd><p>Specific to {-1,1}.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.pairwise">
<code class="descclassname">coniii.enumerate.</code><code class="descname">pairwise</code><span class="sig-paren">(</span><em>n</em>, <em>sym=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.pairwise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.enumerate.triplet">
<code class="descclassname">coniii.enumerate.</code><code class="descname">triplet</code><span class="sig-paren">(</span><em>n</em>, <em>sym=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.triplet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.enumerate.write_eqns">
<code class="descclassname">coniii.enumerate.</code><code class="descname">write_eqns</code><span class="sig-paren">(</span><em>n</em>, <em>sym</em>, <em>terms</em>, <em>writeto='matlab'</em>, <em>suffix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.write_eqns" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spins</dd>
<dt>sym <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>value of 1 will use {-1,1} formulation, 0 means {0,1}</dd>
<dt>terms <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of numpy index arrays as would be returned by np.where that 
specify which terms to include, each consecutive array should 
specify indices in an array with an extra dimension of N, 
[Nx1,NxN,NxNxN,…]
note that the last dimension is the first to be iterated</dd>
<dt>writeto <span class="classifier-delimiter">:</span> <span class="classifier">str,’matlab’</span></dt>
<dd>Filetype to write to, ‘matlab’ or ‘python’.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.write_matlab">
<code class="descclassname">coniii.enumerate.</code><code class="descname">write_matlab</code><span class="sig-paren">(</span><em>n</em>, <em>terms</em>, <em>fitterms</em>, <em>expterms</em>, <em>Z</em>, <em>suffix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.write_matlab" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out equations to solve for matlab.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.enumerate.write_py">
<code class="descclassname">coniii.enumerate.</code><code class="descname">write_py</code><span class="sig-paren">(</span><em>n</em>, <em>terms</em>, <em>fitterms</em>, <em>expterms</em>, <em>Z</em>, <em>extra=''</em>, <em>suffix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.enumerate.write_py" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out equations to solve for Python.</p>
<p>extra (str,’‘) : any extra lines to add at the end</p>
</dd></dl>

</div>
<div class="section" id="module-coniii.general_model_rmc">
<span id="coniii-general-model-rmc-module"></span><h2>coniii.general_model_rmc module<a class="headerlink" href="#module-coniii.general_model_rmc" title="Permalink to this headline">¶</a></h2>
<p>Swendson &amp; Wang Replica Monte Carlo for general ising model.</p>
<p>Author: Colin Clement
Date: 2016-6-11</p>
<p>This implementation follows: arXiv:cond-mat/0407273v1
The only modification is a general implementation for any
graph with two-spin interactions.</p>
<dl class="class">
<dt id="coniii.general_model_rmc.GeneralSpinModel">
<em class="property">class </em><code class="descclassname">coniii.general_model_rmc.</code><code class="descname">GeneralSpinModel</code><span class="sig-paren">(</span><em>J, templist=[1.0], observers=None, sparse=True, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.GeneralSpinModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Swendsen and Wang replica Monte Carlo for ising model with arbitrary
couplings and interaction graphs</p>
<dl class="method">
<dt id="coniii.general_model_rmc.GeneralSpinModel.clusterStep">
<code class="descname">clusterStep</code><span class="sig-paren">(</span><em>s0</em>, <em>T0</em>, <em>s1</em>, <em>T1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.GeneralSpinModel.clusterStep" title="Permalink to this definition">¶</a></dt>
<dd><p>Find clusters of constant overlap between
spin configurations s0 and s1, perform one sweep
of replica cluster Monte Carlo.
input:</p>
<blockquote>
<div>s0: spin configuration 0
T0: Temperature of spin configuration 0
s1: spin configuration 1
T1: Temperature of spin configuration 1</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="coniii.general_model_rmc.GeneralSpinModel.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><em>s</em>, <em>J=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.GeneralSpinModel.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the energy of the current state</p>
</dd></dl>

<dl class="method">
<dt id="coniii.general_model_rmc.GeneralSpinModel.getClusterCouplings">
<code class="descname">getClusterCouplings</code><span class="sig-paren">(</span><em>clusters</em>, <em>s0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.GeneralSpinModel.getClusterCouplings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the effective cluster couplings as prescribed
by Swendsen and Wang.
input:</p>
<blockquote>
<div>clusters: list of lists of cluster indicies
s0: reference spin configuration</div></blockquote>
<dl class="docutils">
<dt>returns:</dt>
<dd>sparse matrix of effective couplings</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.general_model_rmc.GeneralSpinModel.notify_observers">
<code class="descname">notify_observers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.GeneralSpinModel.notify_observers" title="Permalink to this definition">¶</a></dt>
<dd><p>Send state to observers</p>
</dd></dl>

<dl class="method">
<dt id="coniii.general_model_rmc.GeneralSpinModel.thermalize">
<code class="descname">thermalize</code><span class="sig-paren">(</span><em>relax_time</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.GeneralSpinModel.thermalize" title="Permalink to this definition">¶</a></dt>
<dd><p>performs relax_time (int) monte carlo steps</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.boundaries">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">boundaries</code><span class="sig-paren">(</span><em>cls</em>, <em>bonds</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.boundaries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.coroutine">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">coroutine</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.coroutine" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator that initializes coroutines (return yield)</p>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.fileName">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">fileName</code><span class="sig-paren">(</span><em>model</em>, <em>directory='time_series/'</em>, <em>protocol='.pkl'</em>, <em>appendnote=''</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.fileName" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unique file name for a given model final string first 10
characters from the current git commit hash</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.general_model_rmc.flipFast">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">flipFast</code><a class="headerlink" href="#coniii.general_model_rmc.flipFast" title="Permalink to this definition">¶</a></dt>
<dd><p>Much more efficient version of _oneSweep MC
input:</p>
<blockquote>
<div>index: spin to attempt flipping
s: spin configuration
T: temperature
rand: a uniform random float
neighs: list of neighboring sites to index
bonds: list of bonds connections index to its neighbors</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.getClusters">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">getClusters</code><span class="sig-paren">(</span><em>taus</em>, <em>neighborsets</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.getClusters" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>input:</dt>
<dd><dl class="first docutils">
<dt>taus <span class="classifier-delimiter">:</span> <span class="classifier">values of overlap between two spin configurations.</span></dt>
<dd>Array of N spin-values.</dd>
</dl>
<p class="last">neighborsets: list ordered by spin index, whose
elements are the spins neighboring the spin at that index.</p>
</dd>
<dt>output:</dt>
<dd>list of cluster indices split according to the adjacency
matrix to find contiguous regions of ‘up’ or ‘down’ spins</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.mapCij">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">mapCij</code><span class="sig-paren">(</span><em>clust</em>, <em>CIJ</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.mapCij" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ClusterModel correlation function and, using the cluster assignment
inherited from an REMC model, maps the correlation function (CIJ) onto
the dimensions of the original system correlations</p>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.neighbors">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">neighbors</code><span class="sig-paren">(</span><em>ind</em>, <em>adj</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Given adjacency matrix, return the neighbors
of node ‘ind’</p>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.onlinePairCorr">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">onlinePairCorr</code><span class="sig-paren">(</span><em>period=100</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.onlinePairCorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pair correlation function using the same online
Welford-type algorithm as for the FIM. Only calculates cross moments.
PairCorr is calculated upon pickling by dividing by self.pairtime and T**2.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.packSpins">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">packSpins</code><span class="sig-paren">(</span><em>spins</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.packSpins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.pickleLoader">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">pickleLoader</code><span class="sig-paren">(</span><em>pklfile</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.pickleLoader" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.saveTimeSeries">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">saveTimeSeries</code><span class="sig-paren">(</span><em>period=1</em>, <em>directory='time_series/'</em>, <em>protocol='.npy'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.saveTimeSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Observer which saves spin state of model to a file. specify directory to save in,
protocol: ‘pkl’ or ‘h5 for pickling or hdf5</p>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.simplifyNestedClustering">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">simplifyNestedClustering</code><span class="sig-paren">(</span><em>supercluster</em>, <em>cluster</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.simplifyNestedClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks a clustering of clusters. supercluster is a list of indices from
cluster, cluster is a list of original indicies. The output is the indices
of cluster organizes according to supercluster</p>
</dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.timeSeriesLoader">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">timeSeriesLoader</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.timeSeriesLoader" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.general_model_rmc.unpackSpins">
<code class="descclassname">coniii.general_model_rmc.</code><code class="descname">unpackSpins</code><span class="sig-paren">(</span><em>ints</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.general_model_rmc.unpackSpins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.ising">
<span id="coniii-ising-module"></span><h2>coniii.ising module<a class="headerlink" href="#module-coniii.ising" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="coniii-mc-hist-module">
<h2>coniii.mc_hist module<a class="headerlink" href="#coniii-mc-hist-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-coniii.mean_field_ising">
<span id="coniii-mean-field-ising-module"></span><h2>coniii.mean_field_ising module<a class="headerlink" href="#module-coniii.mean_field_ising" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="coniii.mean_field_ising.FHomogeneous">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">FHomogeneous</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.FHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Hubbard-Stratonovich (auxiliary field) to calculate the
(free energy?) of a homogeneous system as a function of the
field m (m equals the mean field as N -&gt; infinity?).</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.JfullFromCluster">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">JfullFromCluster</code><span class="sig-paren">(</span><em>Jcluster</em>, <em>cluster</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.JfullFromCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>There is perhaps a faster way of doing this?</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.JmeanField">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">JmeanField</code><span class="sig-paren">(</span><em>coocMat</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.JmeanField" title="Permalink to this definition">¶</a></dt>
<dd><p>See SmeanField for important optional arguments,
including noninteracting prior weighting.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.SHomogeneous">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">SHomogeneous</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.SHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Hubbard-Stratonovich (auxiliary field) to numerically 
calculate entropy of a homogeneous system.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.SmeanField">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">SmeanField</code><span class="sig-paren">(</span><em>cluster</em>, <em>coocMat</em>, <em>meanFieldPriorLmbda=0.0</em>, <em>numSamples=None</em>, <em>indTerm=True</em>, <em>alternateEnt=False</em>, <em>useRegularizedEq=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.SmeanField" title="Permalink to this definition">¶</a></dt>
<dd><p>meanFieldPriorLmbda (0.): 3.23.2014
indTerm (True)          : As of 2.19.2014, I’m not</p>
<blockquote>
<div>sure whether this term should
be included, but I think so</div></blockquote>
<dl class="docutils">
<dt>alternateEnt (False) <span class="classifier-delimiter">:</span> <span class="classifier">Explicitly calculate entropy</span></dt>
<dd>using the full partition function</dd>
<dt>useRegularizedEq (True) <span class="classifier-delimiter">:</span> <span class="classifier">Use regularized form of equation</span></dt>
<dd>even when meanFieldPriorLmbda = 0.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.aboveDiagFlat">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">aboveDiagFlat</code><span class="sig-paren">(</span><em>mat</em>, <em>keepDiag=False</em>, <em>offDiagMult=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.aboveDiagFlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened list of all elements of the 
matrix above the diagonal.</p>
<p>Use offDiagMult = 2 for symmetric J matrix.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.analyticEntropy">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">analyticEntropy</code><span class="sig-paren">(</span><em>J</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.analyticEntropy" title="Permalink to this definition">¶</a></dt>
<dd><p>In nats.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.avgE">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">avgE</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>ell</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.avgE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.avgmHomogeneous">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">avgmHomogeneous</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.avgmHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.avgxHomogeneous">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">avgxHomogeneous</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.avgxHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.coocCluster">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">coocCluster</code><span class="sig-paren">(</span><em>coocMat</em>, <em>cluster</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.coocCluster" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.coocExpectations">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">coocExpectations</code><span class="sig-paren">(</span><em>J</em>, <em>hext=0</em>, <em>zeroBelowDiag=True</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.coocExpectations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.coocMatBayesianMean">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">coocMatBayesianMean</code><span class="sig-paren">(</span><em>coocMat</em>, <em>numFights</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.coocMatBayesianMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Using “Laplace’s method”</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.coocSampleCovariance">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">coocSampleCovariance</code><span class="sig-paren">(</span><em>samples</em>, <em>bayesianMean=True</em>, <em>includePrior=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.coocSampleCovariance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>includePrior (True) <span class="classifier-delimiter">:</span> <span class="classifier">Include diagonal component corresponding</span></dt>
<dd>to ell*(ell-1)/2 prior residuals for
interaction parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.coocStdevsFlat">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">coocStdevsFlat</code><span class="sig-paren">(</span><em>coocMat</em>, <em>numFights</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.coocStdevsFlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a flattened expected standard deviation matrix used
to divide deltaCooc to turn it into z scores.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.cooccurrence_matrix">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">cooccurrence_matrix</code><span class="sig-paren">(</span><em>samples</em>, <em>keepDiag=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.cooccurrence_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.dFdT">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">dFdT</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.dFdT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.diagFlatIndex">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">diagFlatIndex</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>ell</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.diagFlatIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Should have j&gt;=i…</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.dmdT">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">dmdT</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>ell</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.dmdT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.fightPossibilities">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">fightPossibilities</code><span class="sig-paren">(</span><em>ell</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.fightPossibilities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.findJmatrixAnalytic_CoocMat">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">findJmatrixAnalytic_CoocMat</code><span class="sig-paren">(</span><em>coocMatData</em>, <em>Jinit=None</em>, <em>bayesianMean=False</em>, <em>numSamples=None</em>, <em>priorLmbda=0.0</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.findJmatrixAnalytic_CoocMat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.fourthOrderCoocMat">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">fourthOrderCoocMat</code><span class="sig-paren">(</span><em>samples</em>, <em>slowMethod=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.fourthOrderCoocMat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.independentEntropyHomogeneous">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">independentEntropyHomogeneous</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.independentEntropyHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.independentEntropyHomogeneous2">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">independentEntropyHomogeneous2</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.independentEntropyHomogeneous2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.isingDeltaCooc">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">isingDeltaCooc</code><span class="sig-paren">(</span><em>isingSamples</em>, <em>coocMatDesired</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.isingDeltaCooc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.logCosh">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">logCosh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.logCosh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.m">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">m</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>ell</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.m" title="Permalink to this definition">¶</a></dt>
<dd><p>Careful if T is small for loss of precision?</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.meanFieldStability">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">meanFieldStability</code><span class="sig-paren">(</span><em>J</em>, <em>freqs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.meanFieldStability" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.multiInfoHomogeneous">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">multiInfoHomogeneous</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.multiInfoHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.replaceDiag">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">replaceDiag</code><span class="sig-paren">(</span><em>mat</em>, <em>lst</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.replaceDiag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.seedGenerator">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">seedGenerator</code><span class="sig-paren">(</span><em>seedStart</em>, <em>deltaSeed</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.seedGenerator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.specificHeat">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">specificHeat</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>ell</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.specificHeat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.susc">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">susc</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>ell</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.susc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.symmetrizeUsingUpper">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">symmetrizeUsingUpper</code><span class="sig-paren">(</span><em>mat</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.symmetrizeUsingUpper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.unflatten">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">unflatten</code><span class="sig-paren">(</span><em>flatList</em>, <em>ell</em>, <em>symmetrize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.unflatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of aboveDiagFlat with keepDiag=True.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.unsummedLogZ">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">unsummedLogZ</code><span class="sig-paren">(</span><em>J</em>, <em>hext=0</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.unsummedLogZ" title="Permalink to this definition">¶</a></dt>
<dd><p>J should have h on the diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.unsummedZ">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">unsummedZ</code><span class="sig-paren">(</span><em>J</em>, <em>hext=0</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.unsummedZ" title="Permalink to this definition">¶</a></dt>
<dd><p>J should have h on the diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.mean_field_ising.zeroDiag">
<code class="descclassname">coniii.mean_field_ising.</code><code class="descname">zeroDiag</code><span class="sig-paren">(</span><em>mat</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.mean_field_ising.zeroDiag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.pseudo_inverse_ising">
<span id="coniii-pseudo-inverse-ising-module"></span><h2>coniii.pseudo_inverse_ising module<a class="headerlink" href="#module-coniii.pseudo_inverse_ising" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="coniii.pseudo_inverse_ising.conditionalHessian">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">conditionalHessian</code><span class="sig-paren">(</span><em>r</em>, <em>samples</em>, <em>Jr</em>, <em>minSize=0</em>, <em>pairCoocRhat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.conditionalHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns d^2 conditionalLogLikelihood / d Jri d Jrj,
with shape (dimension of system)x(dimension of system)</p>
<dl class="docutils">
<dt>pairCooc (None) <span class="classifier-delimiter">:</span> <span class="classifier">Pass pairCoocMat(samples) to speed</span></dt>
<dd>calculation.</dd>
</dl>
<p>Current implementation uses more memory for speed.
For large #samples, it may make sense to break up differently
if too much memory is being used.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.pseudo_inverse_ising.conditionalJacobian">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">conditionalJacobian</code><span class="sig-paren">(</span><em>r</em>, <em>samples</em>, <em>Jr</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.conditionalJacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns d conditionalLogLikelihood / d Jr,
with shape (dimension of system)</p>
</dd></dl>

<dl class="function">
<dt id="coniii.pseudo_inverse_ising.conditionalLogLikelihood">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">conditionalLogLikelihood</code><span class="sig-paren">(</span><em>r</em>, <em>samples</em>, <em>Jr</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.conditionalLogLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>(Equals -L_r from my notes.)</p>
<p>r           : individual index
samples     : binary matrix, (# samples) x (dimension of system)
Jr          : (dimension of system) x (1)
minSize (0) : minimum number of participants (set to 2 for fights)</p>
</dd></dl>

<dl class="function">
<dt id="coniii.pseudo_inverse_ising.pairCoocMat">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">pairCoocMat</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.pairCoocMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns matrix of shape (ell)x(# samples)x(ell).</p>
<p>For use with conditionalHessian.</p>
<p>Slow because I haven’t thought of a better way of doing it yet.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.pseudo_inverse_ising.pseudoInverseIsing">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">pseudoInverseIsing</code><span class="sig-paren">(</span><em>samples</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.pseudoInverseIsing" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>minSize (0) <span class="classifier-delimiter">:</span> <span class="classifier">minimum number of participants per sample</span></dt>
<dd>(set to 2 for fights)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.pseudo_inverse_ising.pseudoLogLikelihood">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">pseudoLogLikelihood</code><span class="sig-paren">(</span><em>samples</em>, <em>J</em>, <em>minSize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.pseudoLogLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>samples     : binary matrix, (# samples) x (dimension of system)
J           : (dimension of system) x (dimension of system)</p>
<blockquote>
<div>: J should be symmetric</div></blockquote>
<p>(Could probably be made more efficient.)</p>
</dd></dl>

<dl class="function">
<dt id="coniii.pseudo_inverse_ising.testDerivatives">
<code class="descclassname">coniii.pseudo_inverse_ising.</code><code class="descname">testDerivatives</code><span class="sig-paren">(</span><em>r</em>, <em>i</em>, <em>samples</em>, <em>J</em>, <em>minSize=0</em>, <em>deltaMax=1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.pseudo_inverse_ising.testDerivatives" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.samplers">
<span id="coniii-samplers-module"></span><h2>coniii.samplers module<a class="headerlink" href="#module-coniii.samplers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="coniii.samplers.FastMCIsing">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">FastMCIsing</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>n_cpus=None</em>, <em>rng=None</em>, <em>use_numba=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.FastMCIsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.FastMCIsing.setup_sampling">
<code class="descname">setup_sampling</code><span class="sig-paren">(</span><em>use_numba</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.FastMCIsing.setup_sampling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.FastMCIsing.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.FastMCIsing.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.HamiltonianMC">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">HamiltonianMC</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>random_sample</em>, <em>grad_e=None</em>, <em>dt=0.01</em>, <em>leapfrogN=20</em>, <em>nCpus=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.HamiltonianMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.HamiltonianMC.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>nSamples</em>, <em>nBurn=100</em>, <em>fast=True</em>, <em>x0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.HamiltonianMC.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate nSamples from this Hamiltonian starting from random initial conditions from each sample.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.HamiltonianMC.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>x0</em>, <em>nBurn</em>, <em>saveHistory=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.HamiltonianMC.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single sample by MC sampling from this Hamiltonian. Slow method</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.Heisenberg3DSampler">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">Heisenberg3DSampler</code><span class="sig-paren">(</span><em>J</em>, <em>calc_e</em>, <em>random_sample</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<p>Simple MC Sampling from Heisenberg model with a lot of helpful functions.</p>
<p>generate_samples()
equilibrate_samples()
sample_metropolis()
sample_energy_min()</p>
<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.equilibrate_samples">
<code class="descname">equilibrate_samples</code><span class="sig-paren">(</span><em>samples</em>, <em>n_iters</em>, <em>method='mc'</em>, <em>nCpus=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.equilibrate_samples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>nSamples</em>, <em>n_iters=100</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>sample_size : int</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.grad_E">
<code class="descname">grad_E</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.grad_E" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient wrt theta and phi.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>with dims (nSpins,2) with angles theta and phi</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_energy_min">
<code class="descname">sample_energy_min</code><span class="sig-paren">(</span><em>nFixed=0</em>, <em>rng=&lt;mtrand.RandomState object&gt;</em>, <em>initialState=None</em>, <em>method='powell'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_energy_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local energy minimum given state in angular form. Angular representation makes it easy to be
explicit about constraints on the vectors.</p>
<dl class="docutils">
<dt>initialState <span class="classifier-delimiter">:</span> <span class="classifier">ndarray,None</span></dt>
<dd>n_samples x n_features x 2</dd>
<dt>nFixed <span class="classifier-delimiter">:</span> <span class="classifier">int,0</span></dt>
<dd>Number of vectors that are fixed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_metropolis">
<code class="descname">sample_metropolis</code><span class="sig-paren">(</span><em>oldState</em>, <em>E0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_metropolis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>State to perturb randomly.</dd>
<dt>energy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Energy of configuration.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_nearby_sample">
<code class="descname">sample_nearby_sample</code><span class="sig-paren">(</span><em>X</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_nearby_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly move given state around for new metropolis sample.
Question is whether it is more efficient to push only one of the many vectors around or all of them simultaneously.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_nearby_vector">
<code class="descname">sample_nearby_vector</code><span class="sig-paren">(</span><em>v</em>, <em>nSamples=1</em>, <em>otheta=None</em>, <em>ophi=None</em>, <em>sigma=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_nearby_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample random vector that is nearby. It is important how you choose the width sigma.
NOTE: code might be simplified by using arctan2 instead of arctan</p>
<dl class="docutils">
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>xyz vector about which to sample random vectors</dd>
<dt>nSamples <span class="classifier-delimiter">:</span> <span class="classifier">int,1</span></dt>
<dd>number of random samples</dd>
<dt>otheta <span class="classifier-delimiter">:</span> <span class="classifier">float,None</span></dt>
<dd>polar angle for v</dd>
<dt>ophi <span class="classifier-delimiter">:</span> <span class="classifier">float,None</span></dt>
<dd>azimuthal angle for v</dd>
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">float,.1</span></dt>
<dd>width of Gaussian about v</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="coniii.samplers.Heisenberg3DSampler.to_dict">
<em class="property">classmethod </em><code class="descname">to_dict</code><span class="sig-paren">(</span><em>data</em>, <em>names</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function taking 3d array of of samples and arranging them into n x 3 arrays in a dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.Metropolis">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">Metropolis</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>n_cpus=None</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.Metropolis.generate_cond_samples">
<code class="descname">generate_cond_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>fixed_subset</em>, <em>burn_in=1000</em>, <em>cpucount=None</em>, <em>initial_sample=None</em>, <em>systematic_iter=False</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.generate_cond_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples from conditional distribution (while a subset of the spins are held fixed).
Samples are generated in parallel.</p>
<p>NOTE: There is a bug with multiprocess where many calls to the parallel sampling routine in
a row leads to increasingly slow evaluation of the code.</p>
<p>sample_size : int
fixed_subset : list of duples</p>
<blockquote>
<div>Each duple is the index of the spin and the value to fix it at.  These should be ordered
by spin index.</div></blockquote>
<p>burn_in : int,1000
cpucount : int,None
initial_sample : ndarray,None
systematic_iter : bool,False</p>
<blockquote>
<div>Iterate through spins systematically instead of choosing them randomly.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Metropolis.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>n_iters=1000</em>, <em>systematic_iter=False</em>, <em>saveHistory=False</em>, <em>initial_sample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Metropolis samples using a for loop.</p>
<p>sample_size : int
n_iters : int,1000
systematic_iter : bool,False
saveHistory : bool,False
initial_sample : ndarray,None</p>
<p>history : ndarray</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Metropolis.generate_samples_parallel">
<code class="descname">generate_samples_parallel</code><span class="sig-paren">(</span><em>sample_size</em>, <em>n_iters=1000</em>, <em>cpucount=None</em>, <em>initial_sample=None</em>, <em>systematic_iter=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.generate_samples_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples in parallel and save them into self.samples and their energies into self.E.</p>
<p>sample_size : int
n_iters : int,1000
cpucount : int,None
initial_sample : ndarray,None
systematic_iter : bool,False</p>
<blockquote>
<div>Iterate through spins systematically instead of choosing them randomly.</div></blockquote>
<p>None</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Metropolis.sample_metropolis">
<code class="descname">sample_metropolis</code><span class="sig-paren">(</span><em>sample0</em>, <em>E0</em>, <em>rng=None</em>, <em>flip_site=None</em>, <em>calc_e=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.sample_metropolis" title="Permalink to this definition">¶</a></dt>
<dd><p>Metropolis sampling given an arbitrary sampling function.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.ParallelTempering">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">ParallelTempering</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>temps</em>, <em>sample_size=1000</em>, <em>replica_burnin=100</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.ParallelTempering.autocorr_spin">
<code class="descname">autocorr_spin</code><span class="sig-paren">(</span><em>n_iters</em>, <em>burn_factor</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.autocorr_spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spin autocorrelation.
E[s(t)s(t+dt)]</p>
<p>n_iters
burn_factor</p>
<p>autocorr
repSamples</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.burn_in">
<code class="descname">burn_in</code><span class="sig-paren">(</span><em>n_iter</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.burn_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for iterating sampling without exchanging replicas.</p>
<dl class="docutils">
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of times to iterate through system.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.exchange_measures">
<code class="descname">exchange_measures</code><span class="sig-paren">(</span><em>pn_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.exchange_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for computing exchange probabilities and stay times.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>n_iters=100</em>, <em>initial_burn_factor=10</em>, <em>final_burn_factor=10</em>, <em>burn_factor=1</em>, <em>save_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Burn in, run replica exchange simulation, then burnin.</p>
<dl class="docutils">
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int,100</span></dt>
<dd>Number of times to run the RMC. This involves sampling from each replica N*burn_factor  times.</dd>
<dt>initial_burn_factor,final_burn_factor (int=10)</dt>
<dd>Number of time to iterate through system to burn in at the beginning and at the end.</dd>
<dt>burn_factor <span class="classifier-delimiter">:</span> <span class="classifier">int,1</span></dt>
<dd>Passed into one_step().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.generate_trajectory">
<code class="descname">generate_trajectory</code><span class="sig-paren">(</span><em>n_iters=10</em>, <em>burn_factor=5</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.generate_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Run MC and save at each iteration. Note that this will overwrite current samples stored in replicas.
Save a sample every exchange and a burn factor step.</p>
<p>n_iters : int,10
burn_factor : int,5</p>
<p>repSamples : list of ndarrays</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.iterate_beta">
<code class="descname">iterate_beta</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.iterate_beta" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Effective time at each temperature.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.one_step">
<code class="descname">one_step</code><span class="sig-paren">(</span><em>pool</em>, <em>burn_factor</em>, <em>exchange=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.one_step" title="Permalink to this definition">¶</a></dt>
<dd><p>pool : mp.multiprocess.Pool
burn_factor : int</p>
<blockquote>
<div>Number of times to iterate through the system.</div></blockquote>
<dl class="docutils">
<dt>exchange <span class="classifier-delimiter">:</span> <span class="classifier">bool,True</span></dt>
<dd>Run exchange sampling. This is typically turned off when you just want to burn in the replicas.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.optimize">
<code class="descname">optimize</code><span class="sig-paren">(</span><em>pn_kwargs={'n_iters': 5}</em>, <em>max_iter=10</em>, <em>disp=False</em>, <em>save_history=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply algorithm from Kerler and Rehberg (1994) for finding fixed point for optimal temperatures.
Optimized temperatures rewrite self.temps.</p>
<p>pn_kwargs : dict,{‘n_iters’:5}
max_iter : int,10</p>
<blockquote>
<div>Number of times to iterate algorithm for beta. Each iteration involves sampling from REMC.</div></blockquote>
<dl class="docutils">
<dt>disp <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>Print out updated parameters.</dd>
<dt>save_history <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>If true, return history.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.pn">
<code class="descname">pn</code><span class="sig-paren">(</span><em>n_iters=1</em>, <em>initial_burn_factor=10</em>, <em>burn_factor=1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.pn" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate acceptance probabilities of exchange between two adjacent temperatures. The acceptance
probability is ordered from exchange between replicas i and i+1 starting from i=0.</p>
<p>Estimate stay time at any particular replica.</p>
<dl class="docutils">
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int,100</span></dt>
<dd>Number of times to run the RMC. This involves sampling from each replica N*burn_factor times.</dd>
<dt>initial_burn_factor <span class="classifier-delimiter">:</span> <span class="classifier">int,10</span></dt>
<dd>Burn factor right after setting up random state.</dd>
<dt>burn_factor <span class="classifier-delimiter">:</span> <span class="classifier">int,1</span></dt>
<dd>Passed into one_step().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.setup_replicas">
<code class="descname">setup_replicas</code><span class="sig-paren">(</span><em>burnin</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.setup_replicas" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a set of replicas at different temperatures using the Metropolis algorithm as coded in
FastMCIsing.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.tn">
<code class="descname">tn</code><span class="sig-paren">(</span><em>exchangeix</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.tn" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate stay time at any particular replica given number of exchanges that happened during ReMC steps.
Find stay time at replicas. This is the inverse of the probability that you switch out of a
particular replica. Remember that replicas on the boundaries can only exchange with one other
replica.</p>
<p>exchangeix : ndarray</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>theta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update parameters for each replica.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.SWIsing">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">SWIsing</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>nCpus=None</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.SWIsing.generate_sample">
<code class="descname">generate_sample</code><span class="sig-paren">(</span><em>n_samples</em>, <em>n_iters</em>, <em>initial_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.generate_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>n_samples
n_iters
initial_state : ndarray,None</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.generate_sample_parallel">
<code class="descname">generate_sample_parallel</code><span class="sig-paren">(</span><em>n_samples</em>, <em>n_iters</em>, <em>initial_state=None</em>, <em>n_cpus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.generate_sample_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>n_samples
n_iters
initial_state : ndarray,None</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.get_clusters">
<code class="descname">get_clusters</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.get_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a random sample of clusters.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.one_step">
<code class="descname">one_step</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.one_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.print_cluster_size">
<code class="descname">print_cluster_size</code><span class="sig-paren">(</span><em>n_iters</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.print_cluster_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.randomly_flip_clusters">
<code class="descname">randomly_flip_clusters</code><span class="sig-paren">(</span><em>state</em>, <em>clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.randomly_flip_clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.Sampler">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">Sampler</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for MCMC sampling.</p>
<dl class="method">
<dt id="coniii.samplers.Sampler.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>sample_size : int</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Sampler.generate_samples_parallel">
<code class="descname">generate_samples_parallel</code><span class="sig-paren">(</span><em>sample_size</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.generate_samples_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>sample_size : int</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Sampler.sample_metropolis">
<code class="descname">sample_metropolis</code><span class="sig-paren">(</span><em>s</em>, <em>energy</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.sample_metropolis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>State to perturb randomly.</dd>
<dt>energy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Energy of configuration.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Sampler.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>new_parameters</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.SimulatedTempering">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">SimulatedTempering</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>temps</em>, <em>sample_size=1000</em>, <em>replica_burnin=100</em>, <em>rng=None</em>, <em>method='single'</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.burn_in">
<code class="descname">burn_in</code><span class="sig-paren">(</span><em>n_iter</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.burn_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for iterating sampling without exchanging replicas.
2017-02-27</p>
<dl class="docutils">
<dt>n_iters (int)</dt>
<dd>Number of times to iterate through system.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.exchange_measures">
<code class="descname">exchange_measures</code><span class="sig-paren">(</span><em>pn_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.exchange_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for computing exchange probabilities and stay times.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>n_iters=100</em>, <em>initial_burn_factor=10</em>, <em>final_burn_factor=10</em>, <em>burn_factor=1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Run replica exchange simulation then burnin.
2017-03-01</p>
<dl class="docutils">
<dt>n_iters (int=100)</dt>
<dd>Number of times to run the RMC. This involves sampling from each replica N*burn_factor  times.</dd>
<dt>initial_burn_factor,final_burn_factor (int=10)</dt>
<dd>Number of time to iterate through system to burn in at the beginning and at the end.</dd>
<dt>burn_factor (int=1)</dt>
<dd>Passed into one_step().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.iterate_beta">
<code class="descname">iterate_beta</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.iterate_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>2017-03-01
Parameters
———-
tau (ndarray)</p>
<blockquote>
<div>Effective time at each temperature.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.one_loop">
<code class="descname">one_loop</code><span class="sig-paren">(</span><em>sample</em>, <em>burn_factor</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.one_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Metropolis sample state til it reaches the highest temperature and returns to T=1. At each new
temperature, the sample is iterated burn_factor times.
2017-03-17</p>
<p>pool (mp.multiprocess.Pool)
burn_factor (int)</p>
<blockquote>
<div>Number of times to iterate through the system.</div></blockquote>
<dl class="docutils">
<dt>exchange (bool=True)</dt>
<dd>Run exchange sampling. This is typically turned off when you just want to burn in the replicas.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.optimize">
<code class="descname">optimize</code><span class="sig-paren">(</span><em>interp_kwargs={'kind': 'quadratic'}</em>, <em>pn_kwargs={'n_iters': 5}</em>, <em>max_iter=10</em>, <em>disp=False</em>, <em>save_history=False</em>, <em>threshold=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply algorithm from Kerler and Rehberg (1994) for finding fixed point for optimal temperatures.
Optimized temperatures rewrite self.temps.
2017-03-01</p>
<dl class="docutils">
<dt>interp_kwargs (dict={‘kind’:’quadratic’})</dt>
<dd>Interpoloation for gn(bn) = bn to update gn after beta update step.</dd>
</dl>
<p>pn_kwargs (dict={‘n_iters’:5})
max_iter (int=10)</p>
<blockquote>
<div>Number of times to iterate algorithm for beta. Each iteration involves sampling from REMC.</div></blockquote>
<dl class="docutils">
<dt>disp (bool=False)</dt>
<dd>Print out updated parameters.</dd>
<dt>save_history (bool=False)</dt>
<dd>If true, return history.</dd>
</dl>
<p>threshold (float=1e-2)</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.pn">
<code class="descname">pn</code><span class="sig-paren">(</span><em>n_iters=1</em>, <em>initial_burn_factor=10</em>, <em>burn_factor=1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.pn" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate acceptance probabilities of exchange between two adjacent temperatures. The acceptance
probability is ordered from exchange between replicas i and i+1 starting from i=0.</p>
<p>Estimate stay time at any particular replica.
2017-03-01</p>
<dl class="docutils">
<dt>n_iters (int=100)</dt>
<dd>Number of times to run the RMC. This involves sampling from each replica N*burn_factor times.</dd>
<dt>initial_burn_factor (int=10)</dt>
<dd>Burn factor right after setting up random state.</dd>
<dt>burn_factor (int=1)</dt>
<dd>Passed into one_step().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.reweighted_gn">
<code class="descname">reweighted_gn</code><span class="sig-paren">(</span><em>listOfSample</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.reweighted_gn" title="Permalink to this definition">¶</a></dt>
<dd><p>2017-03-01</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.tn">
<code class="descname">tn</code><span class="sig-paren">(</span><em>exchangeix</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.tn" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate stay time at any particular replica given number of exchanges that happened during ReMC steps.
Find stay time at replicas. This is the inverse of the probability that you switch out of a
particular replica. Remember that replicas on the boundaries can only exchange with one other
replica.
2017-03-01</p>
<p>exchangeix (ndarray)</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SimulatedTempering.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>theta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SimulatedTempering.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.WolffIsing">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">WolffIsing</code><span class="sig-paren">(</span><em>J</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.WolffIsing.build_cluster">
<code class="descname">build_cluster</code><span class="sig-paren">(</span><em>state</em>, <em>initialsite</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.build_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Grow cluster from initial site.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.find_neighbors">
<code class="descname">find_neighbors</code><span class="sig-paren">(</span><em>state</em>, <em>site</em>, <em>alreadyMarked</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.find_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return neighbors of given site that need to be visited excluding sites that have already been visited.
This is the implementation of the Wolff algorithm for finding neighbors such that detailed balance is
satisfied. I have modified to include random fields such tha the probability of adding a neighbors
depends both on its coupling with the current site and the neighbor’s magnetic field.</p>
<p>state
site
alreadyMarked</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.generate_sample">
<code class="descname">generate_sample</code><span class="sig-paren">(</span><em>samplesize</em>, <em>n_iters</em>, <em>initialSample=None</em>, <em>save_history=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.generate_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples by starting from random initial states.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.generate_sample_parallel">
<code class="descname">generate_sample_parallel</code><span class="sig-paren">(</span><em>samplesize</em>, <em>n_iters</em>, <em>initialSample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.generate_sample_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples by starting from random or given initial states.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.one_step">
<code class="descname">one_step</code><span class="sig-paren">(</span><em>state</em>, <em>initialsite=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.one_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the Wolff algorithm that involves finding a cluster and possibly flipping it.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>J</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.calc_e">
<code class="descclassname">coniii.samplers.</code><code class="descname">calc_e</code><a class="headerlink" href="#coniii.samplers.calc_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Heisenberg model.</p>
<dl class="docutils">
<dt>theta <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>List of couplings Jij</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>List of angles (theta_0,phi_0,theta_1,phi_1,…,theta_n,phi_n)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.samplers.check_e_logp">
<code class="descclassname">coniii.samplers.</code><code class="descname">check_e_logp</code><span class="sig-paren">(</span><em>sample</em>, <em>calc_e</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.check_e_logp" title="Permalink to this definition">¶</a></dt>
<dd><p>Boltzmann type model with discrete state space should have E propto -logP. Calculate these quantities for
comparison.</p>
<p>sample
calc_e</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.cross">
<code class="descclassname">coniii.samplers.</code><code class="descname">cross</code><a class="headerlink" href="#coniii.samplers.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cross product of two 3d vectors.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.cross_">
<code class="descclassname">coniii.samplers.</code><code class="descname">cross_</code><a class="headerlink" href="#coniii.samplers.cross_" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cross product of two 3d vectors.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.grad_e">
<code class="descclassname">coniii.samplers.</code><code class="descname">grad_e</code><a class="headerlink" href="#coniii.samplers.grad_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivatives wrt the angles of the spins.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.grad_e_theta">
<code class="descclassname">coniii.samplers.</code><code class="descname">grad_e_theta</code><a class="headerlink" href="#coniii.samplers.grad_e_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivatives wrt the couplings theta.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.samplers.iter_cluster">
<code class="descclassname">coniii.samplers.</code><code class="descname">iter_cluster</code><span class="sig-paren">(</span><em>adj</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.iter_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Cycle through all spins to get clusters.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.iterate_neighbors">
<code class="descclassname">coniii.samplers.</code><code class="descname">iterate_neighbors</code><a class="headerlink" href="#coniii.samplers.iterate_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all neighbors of a particular site and see if a bond should be formed between them.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>System size.</dd>
<dt>ix <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of bool</span></dt>
<dd>Indices of sites that have already been visited.</dd>
<dt>expdJ <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>np.exp( -2*state[:,None]*state[None,:]*J )</dd>
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of random numbers.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.jit_sample">
<code class="descclassname">coniii.samplers.</code><code class="descname">jit_sample</code><a class="headerlink" href="#coniii.samplers.jit_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single sample by MC sampling from this Hamiltonian.</p>
<dl class="docutils">
<dt>theta <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Parameters</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Sample</dd>
</dl>
<p>nBurn : int
dt : float
leapfrogN : int
randNormal : ndarray</p>
<blockquote>
<div>nBurn x ndim</div></blockquote>
<dl class="docutils">
<dt>randUnif <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>nBurn</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.jit_sample_nearby_vector">
<code class="descclassname">coniii.samplers.</code><code class="descname">jit_sample_nearby_vector</code><a class="headerlink" href="#coniii.samplers.jit_sample_nearby_vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.pairwise_prod">
<code class="descclassname">coniii.samplers.</code><code class="descname">pairwise_prod</code><a class="headerlink" href="#coniii.samplers.pairwise_prod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.sample_bonds">
<code class="descclassname">coniii.samplers.</code><code class="descname">sample_bonds</code><a class="headerlink" href="#coniii.samplers.sample_bonds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Probability of bond formation.</dd>
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Random numbers.</dd>
</dl>
<p>state
J</p>
</dd></dl>

<dl class="function">
<dt id="coniii.samplers.spec_cluster">
<code class="descclassname">coniii.samplers.</code><code class="descname">spec_cluster</code><span class="sig-paren">(</span><em>L</em>, <em>exact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.spec_cluster" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>L <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Graph Laplacian</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-coniii.solvers">
<span id="coniii-solvers-module"></span><h2>coniii.solvers module<a class="headerlink" href="#module-coniii.solvers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="coniii.solvers.ClusterExpansion">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">ClusterExpansion</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.Solver" title="coniii.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.Solver</span></code></a></p>
<p>Implementation of Adaptive Cluster Expansion for solving the inverse Ising problem, as
described in John Barton and Simona Cocco, J. of Stat. Mech.  P03002 (2013).</p>
<p>Specific to pairwise Ising constraints.</p>
<dl class="method">
<dt id="coniii.solvers.ClusterExpansion.S">
<code class="descname">S</code><span class="sig-paren">(</span><em>cluster</em>, <em>coocMat</em>, <em>deltaJdict={}</em>, <em>useAnalyticResults=False</em>, <em>priorLmbda=0.0</em>, <em>numSamples=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion.S" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate pairwise entropy of cluster.
(First fits pairwise Ising model.)</p>
<dl class="docutils">
<dt>useAnalyticResults <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>Probably want False until analytic formulas are changed to include prior on J</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.ClusterExpansion.Sindependent">
<code class="descname">Sindependent</code><span class="sig-paren">(</span><em>cluster</em>, <em>coocMat</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion.Sindependent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.solvers.ClusterExpansion.clusterID">
<code class="descname">clusterID</code><span class="sig-paren">(</span><em>cluster</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion.clusterID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.solvers.ClusterExpansion.deltaS">
<code class="descname">deltaS</code><span class="sig-paren">(</span><em>cluster</em>, <em>coocMat</em>, <em>deltaSdict=None</em>, <em>deltaJdict=None</em>, <em>verbose=True</em>, <em>meanFieldRef=False</em>, <em>priorLmbda=0.0</em>, <em>numSamples=None</em>, <em>independentRef=False</em>, <em>meanFieldPriorLmbda=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion.deltaS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>cluster <span class="classifier-delimiter">:</span> <span class="classifier">list </span></dt>
<dd>List of indices in cluster</dd>
<dt>independentRef <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>If True, expand about independent entropy</dd>
<dt>meanFieldRef <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>If True, expand about mean field entropy</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.ClusterExpansion.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>X</em>, <em>threshold</em>, <em>cluster=None</em>, <em>deltaSdict=None</em>, <em>deltaJdict=None</em>, <em>verbose=True</em>, <em>priorLmbda=0.0</em>, <em>numSamples=None</em>, <em>meanFieldRef=False</em>, <em>independentRef=True</em>, <em>veryVerbose=False</em>, <em>meanFieldPriorLmbda=None</em>, <em>return_all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion.solve" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd>Data set (n_samples,n_dim).</dd>
</dl>
<p>threshold : float
meanFieldRef : bool,False</p>
<blockquote>
<div>Expand about mean-field reference</div></blockquote>
<dl class="docutils">
<dt>independentRef <span class="classifier-delimiter">:</span> <span class="classifier">bool,True</span></dt>
<dd>Expand about independent reference</dd>
<dt>priorLmbda <span class="classifier-delimiter">:</span> <span class="classifier">float,0.</span></dt>
<dd>Strength of non-interacting prior</dd>
<dt>meanFieldPriorLmbda <span class="classifier-delimiter">:</span> <span class="classifier">float,None</span></dt>
<dd>Strength of non-interacting prior in mean field calculation
(defaults to priorLmbda)</dd>
</dl>
<dl class="docutils">
<dt>With return_all=False, returns</dt>
<dd>J           : Estimated interaction matrix</dd>
<dt>With return_all=True, returns</dt>
<dd>ent         : Estimated entropy
J           : Estimated interaction matrix
clusters    : List of clusters
deltaSdict  : 
deltaJdict  :</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.ClusterExpansion.subsets">
<code class="descname">subsets</code><span class="sig-paren">(</span><em>set</em>, <em>size</em>, <em>sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.ClusterExpansion.subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list, returns a list of all unique subsets
of that list with given size.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.Enumerate">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">Enumerate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.Solver" title="coniii.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.Solver</span></code></a></p>
<p>Class for solving +/-1 symmetric Ising model maxent problems by gradient descent with flexibility to put
in arbitrary constraints.</p>
<dl class="method">
<dt id="coniii.solvers.Enumerate.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>constraints=None</em>, <em>samples=None</em>, <em>initial_guess=None</em>, <em>max_param_value=50</em>, <em>fsolve_kwargs={'method': 'powell'}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Enumerate.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>constraints : ndarray
samples : ndarray</p>
<blockquote>
<div>(n_samples, n_dim)</div></blockquote>
<dl class="docutils">
<dt>initial_guess <span class="classifier-delimiter">:</span> <span class="classifier">ndarray,None</span></dt>
<dd>initial starting point</dd>
<dt>fsolve_kwargs <span class="classifier-delimiter">:</span> <span class="classifier">dict,{‘method’:’powell’}</span></dt>
<dd>Powell method is slower but tends to converge better.</dd>
</dl>
<p>Tuple of solved parameters and output from scipy.optimize.minimize</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.MCH">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">MCH</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.Solver" title="coniii.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.Solver</span></code></a></p>
<p>Class for solving maxent problems using the Monte Carlo Histogram method.</p>
<p>Broderick, T., Dudik, M., Tkacik, G., Schapire, R. E. &amp; Bialek, W. Faster solutions of the
inverse pairwise Ising problem. arXiv 1-8 (2007).</p>
<p>constraints : ndarray
calc_observables (function)</p>
<blockquote>
<div>takes in samples as argument</div></blockquote>
<dl class="docutils">
<dt>calc_e (function)</dt>
<dd>with args (sample,parameters) where sample is 2d</dd>
</dl>
<p>mch_approximation (function)
sampleSize : int
multipliers : ndarray</p>
<blockquote>
<div>set the Langrangian multipliers</div></blockquote>
<dl class="method">
<dt id="coniii.solvers.MCH.estimate_jac">
<code class="descname">estimate_jac</code><span class="sig-paren">(</span><em>eps=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCH.estimate_jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximation Jacobian using the MCH approximation.</p>
<p>eps : float,1e-3</p>
<dl class="docutils">
<dt>jac <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Jacobian is an n x n matrix where each row corresponds to the behavior of fvec wrt to a
single parameter.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.MCH.learn_parameters_mch">
<code class="descname">learn_parameters_mch</code><span class="sig-paren">(</span><em>estConstraints</em>, <em>maxdlamda=1</em>, <em>maxdlamdaNorm=1</em>, <em>maxLearningSteps=50</em>, <em>eta=1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCH.learn_parameters_mch" title="Permalink to this definition">¶</a></dt>
<dd><p>estConstraints : ndarray
maxdlamda : float,1
maxdlamdaNorm : float,1
maxLearningSteps : int</p>
<blockquote>
<div>max learning steps before ending MCH</div></blockquote>
<dl class="docutils">
<dt>eta <span class="classifier-delimiter">:</span> <span class="classifier">float,1</span></dt>
<dd>factor for changing dlamda</dd>
</dl>
<p>estimatedConstraints : ndarray</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.MCH.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>initial_guess=None</em>, <em>constraints=None</em>, <em>X=None</em>, <em>tol=None</em>, <em>tolNorm=None</em>, <em>n_iters=30</em>, <em>burnin=30</em>, <em>maxiter=10</em>, <em>custom_convergence_f=None</em>, <em>disp=False</em>, <em>full_output=False</em>, <em>learn_params_kwargs={'eta': 1</em>, <em>'maxdlamda': 1}</em>, <em>generate_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCH.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve for maxent model parameters using MCH routine.</p>
<dl class="docutils">
<dt>initial_guess <span class="classifier-delimiter">:</span> <span class="classifier">ndarray,None</span></dt>
<dd>Initial starting point</dd>
</dl>
<p>constraints : ndarray,None
X : ndarray,None</p>
<blockquote>
<div>If instead of constraints, you wish to pass the raw data on which to calculate the
constraints using self.calc_observables.</div></blockquote>
<dl class="docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float,None</span></dt>
<dd>Maximum error allowed in any observable.</dd>
<dt>tolNorm <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Norm error allowed in found solution.</dd>
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int,30</span></dt>
<dd>Number of iterations to make between samples in MCMC sampling.</dd>
<dt>burnin <span class="classifier-delimiter">:</span> <span class="classifier">int,30</span></dt>
<dd>Initial burn in from random sample when MC sampling.</dd>
<dt>max_iter <span class="classifier-delimiter">:</span> <span class="classifier">int,10</span></dt>
<dd>Max number of iterations of MC sampling and MCH approximation.</dd>
<dt>custom_convergence_f <span class="classifier-delimiter">:</span> <span class="classifier">function,None</span></dt>
<dd><p class="first">Function for determining convergence criterion. At each iteration, this function should
return the next set of learn_params_kwargs and optionally the sample size.</p>
<p>As an example:
def learn_settings(i):</p>
<blockquote class="last">
<div><p>‘’’
Take in the iteration counter and set the maximum change allowed in any given 
parameter (maxdlamda) and the multiplicative factor eta, where 
d(parameter) = (error in observable) * eta.</p>
<p>Additional option is to also return the sample size for that step by returning a 
tuple. Larger sample sizes are necessary for higher accuracy.
‘’’
if i&lt;10:</p>
<blockquote>
<div>return {‘maxdlamda’:1,’eta’:1}</div></blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>return {‘maxdlamda’:.05,’eta’:.05}</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>disp : bool,False
full_output : bool,False</p>
<blockquote>
<div>If True, also return the errflag and error history.</div></blockquote>
<p>learn_parameters_kwargs : dict,{‘maxdlamda’:1,’eta’:1}
generate_kwargs : dict,{}</p>
<dl class="docutils">
<dt>parameters <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Found solution to inverse problem.</dd>
<dt>errflag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>0, converged within given criterion
1, max iterations reached</dd>
<dt>errors <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Log of errors in matching constraints at each step of iteration.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.MCHIncompleteData">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">MCHIncompleteData</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCHIncompleteData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.MCH" title="coniii.solvers.MCH"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.MCH</span></code></a></p>
<p>Class for solving maxent problems using the Monte Carlo Histogram method on
incomplete data where some spins may not be visible.</p>
<p>Broderick, T., Dudik, M., Tkacik, G., Schapire, R. E. &amp; Bialek, W. Faster
solutions of the inverse pairwise Ising problem. arXiv 1-8 (2007).</p>
<dl class="docutils">
<dt>NOTE: This only works for Ising model.</dt>
<dd>Not ready for release.</dd>
</dl>
<dl class="method">
<dt id="coniii.solvers.MCHIncompleteData.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>n_iters</em>, <em>burnin</em>, <em>uIncompleteStates=None</em>, <em>f_cond_sample_size=None</em>, <em>f_cond_sample_iters=None</em>, <em>sample_size=None</em>, <em>sample_method=None</em>, <em>initial_sample=None</em>, <em>run_regular_sampler=True</em>, <em>run_cond_sampler=True</em>, <em>disp=0</em>, <em>generate_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCHIncompleteData.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around generate_samples_parallel() from available samplers.</p>
<p>n_iters : int
burnin : int</p>
<blockquote>
<div>I think burn in is handled automatically in REMC.</div></blockquote>
<p>uIncompleteStates : list of unique states
f_cond_sample_size : lambda function</p>
<blockquote>
<div>Given the number of hidden spins, return the number of samples to take.</div></blockquote>
<dl class="docutils">
<dt>f_cond_sample_iters <span class="classifier-delimiter">:</span> <span class="classifier">lambda function</span></dt>
<dd>Given the number of hidden spins, return the number of MC iterations to make.</dd>
</dl>
<p>sample_size : int
sample_method : str
initial_sample : ndarray
generate_kwargs : dict</p>
<p>None</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.MCHIncompleteData.learn_parameters_mch">
<code class="descname">learn_parameters_mch</code><span class="sig-paren">(</span><em>estConstraints</em>, <em>fullFraction</em>, <em>uIncompleteStates</em>, <em>uIncompleteStatesCount</em>, <em>maxdlamda=1</em>, <em>maxdlamdaNorm=1</em>, <em>maxLearningSteps=50</em>, <em>eta=1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCHIncompleteData.learn_parameters_mch" title="Permalink to this definition">¶</a></dt>
<dd><p>Update parameters with MCH step. Update is proportional to the difference between the
observables and the predicted observables after a small change to the parameters. This is
calculated from likelihood maximization, and for the incomplete data points this corresponds
to the marginal probability distribution weighted with the number of corresponding data
points.</p>
<p>estConstraints : ndarray
fullFraction : float</p>
<blockquote>
<div>Fraction of data points that are complete.</div></blockquote>
<dl class="docutils">
<dt>uIncompleteStates <span class="classifier-delimiter">:</span> <span class="classifier">list-like</span></dt>
<dd>Unique incomplete states in data.</dd>
<dt>uIncompleteStatesCount <span class="classifier-delimiter">:</span> <span class="classifier">list-like</span></dt>
<dd>Frequency of each unique data point.</dd>
</dl>
<p>maxdlamda : float,1
maxdlamdaNorm : float,1
maxLearningSteps : int</p>
<blockquote>
<div>max learning steps before ending MCH</div></blockquote>
<dl class="docutils">
<dt>eta <span class="classifier-delimiter">:</span> <span class="classifier">float,1</span></dt>
<dd>factor for changing dlamda</dd>
</dl>
<p>estimatedConstraints : ndarray</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.MCHIncompleteData.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>X=None</em>, <em>constraints=None</em>, <em>initial_guess=None</em>, <em>cond_sample_size=100</em>, <em>cond_sample_iters=100</em>, <em>tol=None</em>, <em>tolNorm=None</em>, <em>n_iters=30</em>, <em>burnin=30</em>, <em>maxiter=10</em>, <em>disp=False</em>, <em>full_output=False</em>, <em>learn_params_kwargs={}</em>, <em>generate_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MCHIncompleteData.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve for parameters using MCH routine.</p>
<p>X                       : ndarray
constraints             : ndarray</p>
<blockquote>
<div>Constraints calculated from the incomplete data (accounting for missing data points).</div></blockquote>
<dl class="docutils">
<dt>initial_guess <span class="classifier-delimiter">:</span> <span class="classifier">ndarray=None</span></dt>
<dd>initial starting point</dd>
<dt>cond_sample_size <span class="classifier-delimiter">:</span> <span class="classifier">int or function</span></dt>
<dd>Number of samples to make for conditional distribution.
If function is passed in, it will be passed number of missing spins and must return an int.</dd>
<dt>cond_sample_iters <span class="classifier-delimiter">:</span> <span class="classifier">int or function</span></dt>
<dd>Number of MC iterations to make between samples.</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float=None</span></dt>
<dd>maximum error allowed in any observable</dd>
<dt>tolNorm <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>norm error allowed in found solution</dd>
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int=30</span></dt>
<dd>Number of iterations to make between samples in MCMC sampling.</dd>
</dl>
<p>burnin (int=30)
disp                    : int=0</p>
<blockquote>
<div>0, no output
1, some detail
2, most detail</div></blockquote>
<dl class="docutils">
<dt>full_output <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>Return errflag and errors at each iteration if True.</dd>
</dl>
<p>learn_parameters_kwargs : dict
generate_kwargs         : dict</p>
<dl class="docutils">
<dt>parameters <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Found solution.</dd>
</dl>
<p>errflag : int
errors : ndarray</p>
<blockquote>
<div>Errors in matching constraints at each step of iteration.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.MPF">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">MPF</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MPF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.Solver" title="coniii.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.Solver</span></code></a></p>
<dl class="method">
<dt id="coniii.solvers.MPF.K">
<code class="descname">K</code><span class="sig-paren">(</span><em>Xuniq</em>, <em>Xcount</em>, <em>adjacentStates</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MPF.K" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute objective function.</p>
<dl class="docutils">
<dt>Xuniq <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>(ndata x ndims)
unique states that appear in the data</dd>
<dt>Xcount <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of int</span></dt>
<dd>number of times that each unique state appears in the data</dd>
<dt>adjacentStates <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarray</span></dt>
<dd>list of adjacent states for each given unique state</dd>
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>parameters for computation of energy</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.MPF.logK">
<code class="descname">logK</code><span class="sig-paren">(</span><em>Xuniq</em>, <em>Xcount</em>, <em>adjacentStates</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MPF.logK" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute log of objective function.</p>
<dl class="docutils">
<dt>Xuniq <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>(n_samples, n_dim)
unique states that appear in the data</dd>
<dt>Xcount <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of int</span></dt>
<dd>number of times that each unique state appears in the data</dd>
<dt>adjacentStates <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarray</span></dt>
<dd>list of adjacent states for each given unique state</dd>
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>parameters for computation of energy</dd>
</dl>
<p>logK : float</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.MPF.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>X=None</em>, <em>initial_guess=None</em>, <em>method='L-BFGS-B'</em>, <em>all_connected=True</em>, <em>parameter_limits=100</em>, <em>solver_kwargs={'disp': True</em>, <em>'ftol': 1e-15</em>, <em>'maxiter': 100}</em>, <em>uselog=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MPF.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize MPF objective function using scipy.optimize.minimize.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>(ndata, ndim)
array of states compatible with given energy and adjacent neighbors functions</dd>
<dt>adj <span class="classifier-delimiter">:</span> <span class="classifier">lambda state</span></dt>
<dd>returns adjacent states for any given state</dd>
<dt>all_connected <span class="classifier-delimiter">:</span> <span class="classifier">bool,True</span></dt>
<dd>switch for summing over all states that data sets could be connected to or just summing over
non-data states (second summation in Eq 10 in Sohl-Dickstein 2011)</dd>
<dt>iterate <span class="classifier-delimiter">:</span> <span class="classifier">int,0</span></dt>
<dd>number of times to try new initial conditions if first try doesn’t work. Right now, this is a
pretty coarse test because the fit can be good even without converging.</dd>
<dt>parameter_limits <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>some limit to constrain the space that the solver has to search. This is the maximum allowed
magnitude of any single parameter.</dd>
<dt>solver_kwargs <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>For scipy.optimize.minimize.</dd>
</dl>
<dl class="docutils">
<dt>soln <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>found solution to problem</dd>
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>full output from minimize solver</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="coniii.solvers.MPF.worker_objective_task">
<em class="property">static </em><code class="descname">worker_objective_task</code><span class="sig-paren">(</span><em>s</em>, <em>Xcount</em>, <em>adjacentStates</em>, <em>params</em>, <em>calc_e</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.MPF.worker_objective_task" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.Pseudo">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">Pseudo</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.Solver" title="coniii.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.Solver</span></code></a></p>
<p>Pseudolikelihood approximation to solving the inverse Ising problem as described in Aurell
and Ekeberg, PRL 108, 090201 (2012).</p>
<p>solve
_solve
cond_log_likelihood
cond_jac
cond_hess</p>
<dl class="method">
<dt id="coniii.solvers.Pseudo.cond_hess">
<code class="descname">cond_hess</code><span class="sig-paren">(</span><em>r</em>, <em>X</em>, <em>Jr</em>, <em>pairCoocRhat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo.cond_hess" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns d^2 cond_log_likelihood / d Jri d Jrj, with shape
(dimension of system)x(dimension of system)</p>
<p>Current implementation uses more memory for speed.
For large sample size, it may make sense to break up differently
if too much memory is being used.</p>
<dl class="docutils">
<dt>pairCooc <span class="classifier-delimiter">:</span> <span class="classifier">ndarray,None</span></dt>
<dd>Pass pair_cooc_mat(X) to speed calculation.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Pseudo.cond_jac">
<code class="descname">cond_jac</code><span class="sig-paren">(</span><em>r</em>, <em>X</em>, <em>Jr</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo.cond_jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns d cond_log_likelihood / d Jr,
with shape (dimension of system)</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Pseudo.cond_log_likelihood">
<code class="descname">cond_log_likelihood</code><span class="sig-paren">(</span><em>r</em>, <em>X</em>, <em>Jr</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo.cond_log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Equals the conditional log likelihood -L_r.</p>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>individual index</dd>
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>binary matrix, (# X) x (dimension of system)</dd>
<dt>Jr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>(dimension of system) x (1)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Pseudo.pair_cooc_mat">
<code class="descname">pair_cooc_mat</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo.pair_cooc_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns matrix of shape (self.n)x(# X)x(self.n).</p>
<p>For use with cond_hess.</p>
<p>Slow because I haven’t thought of a better way of doing it yet.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Pseudo.pseudo_log_likelhood">
<code class="descname">pseudo_log_likelhood</code><span class="sig-paren">(</span><em>X</em>, <em>J</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo.pseudo_log_likelhood" title="Permalink to this definition">¶</a></dt>
<dd><p>(Could probably be made more efficient.)</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>binary matrix, (# of samples) x (dimension of system)</dd>
<dt>J <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>(dimension of system) x (dimension of system)
J should be symmetric</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Pseudo.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Pseudo.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Two different methods are implemented and can be called from self.solve. One is specific to
the Ising model and the other uses a general all-purpose optimization (scipy.optimize) to
solve the problem.</p>
<dl class="docutils">
<dt>general_case <span class="classifier-delimiter">:</span> <span class="classifier">bool,True</span></dt>
<dd>If True, uses self.calc_observables_r and self.get_multipliers_r to maximize the
resulting pseudolikelihood (self._solve_general). Else an algorithm specific to the Ising model is
implemented (self._solve_ising).</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.RegularizedMeanField">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">RegularizedMeanField</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.RegularizedMeanField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.solvers.Solver" title="coniii.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.solvers.Solver</span></code></a></p>
<p>Implementation of regularized mean field method for solving the inverse Ising problem, as
described in Daniels, Bryan C., David C. Krakauer, and Jessica C. Flack.  <a href="#id1"><span class="problematic" id="id2">``</span></a>Control of
Finite Critical Behaviour in a Small-Scale Social System.’’ Nature Communications 8 (2017):
14301.  doi:10.1038/ncomms14301</p>
<p>Specific to pairwise Ising constraints.</p>
<dl class="method">
<dt id="coniii.solvers.RegularizedMeanField.bracket1d">
<code class="descname">bracket1d</code><span class="sig-paren">(</span><em>xList</em>, <em>funcList</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.RegularizedMeanField.bracket1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Assumes xList is monotonically increasing</p>
<p>Get bracketed interval (a,b,c) with a &lt; b &lt; c, and f(b) &lt; f(a) and f(c).
(Choose b and c to make f(b) and f(c) as small as possible.)</p>
<p>If minimum is at one end, raise error.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.RegularizedMeanField.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>samples</em>, <em>numSamples=100000.0</em>, <em>nSkip=None</em>, <em>seed=0</em>, <em>changeSeed=False</em>, <em>numProcs=1</em>, <em>numDataSamples=None</em>, <em>minSize=0</em>, <em>minimizeCovariance=False</em>, <em>minimizeIndependent=True</em>, <em>coocCov=None</em>, <em>priorLmbda=0.0</em>, <em>bracket=None</em>, <em>numGridPoints=200</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.RegularizedMeanField.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Varies the strength of regularization on the mean field J to best fit given cooccurrence
data.</p>
<dl class="docutils">
<dt>numGridPoints (200) <span class="classifier-delimiter">:</span> <span class="classifier">If bracket is given, first test at numGridPoints</span></dt>
<dd>points evenly spaced in the bracket interval, then give
the lowest three points to scipy.optimize.minimize_scalar</dd>
</dl>
<p>numSamples (1e5)            : 
nSkip (None)                :
seed (0)                    :
changeSeed (False)          :
numProcs (1)                :
minSize (0)                 : 3.8.2013 Use a modified model in which</p>
<blockquote>
<div>samples with fewer ones than minSize are not
allowed.</div></blockquote>
<dl class="docutils">
<dt>gradDesc (False) <span class="classifier-delimiter">:</span> <span class="classifier">5.29.2013 Take a naive gradient descent step</span></dt>
<dd>after each LM minimization</dd>
<dt>minimizeCovariance (False) <span class="classifier-delimiter">:</span> <span class="classifier">** As of 7.20.2017, not currently supported **</span></dt>
<dd>6.3.2013 Minimize covariance from emperical
frequencies (see notes); trying to avoid
biases, as inspired by footnote 12 in 
TkaSchBer06</dd>
<dt>minimizeIndependent (True) <span class="classifier-delimiter">:</span> <span class="classifier">** As of 7.20.2017, minimizeIndependent is </span></dt>
<dd><blockquote class="first">
<div>the only mode currently supported **</div></blockquote>
<p class="last">2.7.2014 Each &lt;xi&gt; and &lt;xi xj&gt; residual is treated
as independent</p>
</dd>
<dt>coocCov (None) <span class="classifier-delimiter">:</span> <span class="classifier">** As of 7.20.2017, not currently supported **</span></dt>
<dd>2.7.2014 Provide a covariance matrix for
residuals.  Should typically be 
coocSampleCovariance(samples).  Only used
if minimizeCovariance and minimizeIndependent
are False.</dd>
<dt>priorLmbda (0.) <span class="classifier-delimiter">:</span> <span class="classifier">** As of 7.20.2017, not currently implemented **</span></dt>
<dd>Strength of noninteracting prior.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.solvers.Solver">
<em class="property">class </em><code class="descclassname">coniii.solvers.</code><code class="descname">Solver</code><span class="sig-paren">(</span><em>n</em>, <em>calc_de=None</em>, <em>calc_observables=None</em>, <em>calc_observables_multipliers=None</em>, <em>adj=None</em>, <em>multipliers=None</em>, <em>constraints=None</em>, <em>sample_size=None</em>, <em>sample_method=None</em>, <em>mch_approximation=None</em>, <em>n_cpus=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for declaring common methods and attributes for inverse maxent algorithms.</p>
<p>constraints : ndarray
calc_e : lambda function</p>
<blockquote>
<div>Takes states and parameters to calculate the energies.</div></blockquote>
<dl class="docutils">
<dt>calc_observables <span class="classifier-delimiter">:</span> <span class="classifier">lambda function</span></dt>
<dd>Calculate observables from given sample of states.
lambda X: Y
where X is of dimensions (n_samples, n_dim)
and Y is of dimensions (n_samples, n_constraints)</dd>
<dt>multipliers <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Langrangian multipliers</dd>
</dl>
<p>estimate_jac
generate_samples
setup_sampler
solve</p>
<dl class="method">
<dt id="coniii.solvers.Solver.estimate_jac">
<code class="descname">estimate_jac</code><span class="sig-paren">(</span><em>eps=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Solver.estimate_jac" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.solvers.Solver.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>n_iters</em>, <em>burnin</em>, <em>multipliers=None</em>, <em>sample_size=None</em>, <em>sample_method=None</em>, <em>initial_sample=None</em>, <em>generate_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Solver.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around generate_samples_parallel() methods in samplers.</p>
<p>Samples are saved to self.samples.</p>
<p>n_iters : int
burnin : int</p>
<blockquote>
<div>Burn in is handled automatically in REMC.</div></blockquote>
<p>multipliers : ndarray,None
sample_size : int,None
sample_method : str,None
initial_sample : ndarray,None
generate_kwargs : dict,{}</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Solver.setup_sampler">
<code class="descname">setup_sampler</code><span class="sig-paren">(</span><em>sample_method=None</em>, <em>sampler_kwargs={}</em>, <em>optimize_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Solver.setup_sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate sampler class object.</p>
<dl class="docutils">
<dt>sample_method <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>‘ising_metropolis’, ‘metropolis’</dd>
</dl>
<p>sampler_kwargs : dict
optimize_kwargs : dict</p>
</dd></dl>

<dl class="method">
<dt id="coniii.solvers.Solver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="coniii.solvers.unwrap_self_worker_obj">
<code class="descclassname">coniii.solvers.</code><code class="descname">unwrap_self_worker_obj</code><span class="sig-paren">(</span><em>arg</em>, <em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.solvers.unwrap_self_worker_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.test_samplers">
<span id="coniii-test-samplers-module"></span><h2>coniii.test_samplers module<a class="headerlink" href="#module-coniii.test_samplers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="coniii.test_samplers.test_FastMCIsing">
<code class="descclassname">coniii.test_samplers.</code><code class="descname">test_FastMCIsing</code><span class="sig-paren">(</span><em>run_timing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.test_samplers.test_FastMCIsing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.test_samplers.test_Metropolis">
<code class="descclassname">coniii.test_samplers.</code><code class="descname">test_Metropolis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.test_samplers.test_Metropolis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.test_solvers">
<span id="coniii-test-solvers-module"></span><h2>coniii.test_solvers module<a class="headerlink" href="#module-coniii.test_solvers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="coniii.test_solvers.test_pickling">
<code class="descclassname">coniii.test_solvers.</code><code class="descname">test_pickling</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.test_solvers.test_pickling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.test_utils">
<span id="coniii-test-utils-module"></span><h2>coniii.test_utils module<a class="headerlink" href="#module-coniii.test_utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="coniii.test_utils.test_convert_params">
<code class="descclassname">coniii.test_utils.</code><code class="descname">test_convert_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.test_utils.test_convert_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.test_utils.test_state_gen_and_count">
<code class="descclassname">coniii.test_utils.</code><code class="descname">test_state_gen_and_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.test_utils.test_state_gen_and_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Test generation of binary states using bin_states() and xbin_states().</p>
</dd></dl>

<dl class="function">
<dt id="coniii.test_utils.test_sub_to_ind">
<code class="descclassname">coniii.test_utils.</code><code class="descname">test_sub_to_ind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.test_utils.test_sub_to_ind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-coniii.utils">
<span id="coniii-utils-module"></span><h2>coniii.utils module<a class="headerlink" href="#module-coniii.utils" title="Permalink to this headline">¶</a></h2>
<dl class="attribute">
<dt id="coniii.utils.adj">
<code class="descclassname">coniii.utils.</code><code class="descname">adj</code><a class="headerlink" href="#coniii.utils.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return one-flip neighbors and a set of random neighbors. This is written to be used with
the solvers.MPF class. Use adj_sym() if symmetric spins in {-1,1} are needed.</p>
<p>NOTE: For random neighbors, there is no check to make sure neighbors don’t repeat but this
shouldn’t be a problem as long as state space is large enough.</p>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>State whose neighbors are found. One-dimensional vector of spins.</dd>
<dt>n_random_neighbors <span class="classifier-delimiter">:</span> <span class="classifier">int,0</span></dt>
<dd>If &gt;0, return this many random neighbors. Neighbors are just random states, but they are
called “neighbors” because of the terminology in MPF.</dd>
</dl>
<dl class="docutils">
<dt>neighbors <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Each row is a neighbor. s.size + n_random_neighbors are returned.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.adj_sym">
<code class="descclassname">coniii.utils.</code><code class="descname">adj_sym</code><a class="headerlink" href="#coniii.utils.adj_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetric version of adj() where spins are in {-1,1}.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.bin_states">
<code class="descclassname">coniii.utils.</code><code class="descname">bin_states</code><span class="sig-paren">(</span><em>n</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.bin_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all possible binary spin states.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spins</dd>
<dt>sym <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if true, return {-1,1} basis</dd>
</dl>
<p>v : ndarray</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.calc_de">
<code class="descclassname">coniii.utils.</code><code class="descname">calc_de</code><span class="sig-paren">(</span><em>s</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.calc_de" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the derivative of the energy wrt parameters given the state and
index of the parameter. In this case, the parameters are the concatenated
vector of {h_i,J_ij}.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.calc_overlap">
<code class="descclassname">coniii.utils.</code><code class="descname">calc_overlap</code><span class="sig-paren">(</span><em>sample</em>, <em>ignore_zeros=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.calc_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;si_a si_b&gt; between all pairs of replicas a and b</p>
<p>sample
ignore_zeros (bool=False)</p>
<blockquote>
<div>Instead of normalizing by the number of spins, normalize by the minimum number of nonzero spins.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.convert_corr">
<code class="descclassname">coniii.utils.</code><code class="descname">convert_corr</code><span class="sig-paren">(</span><em>si</em>, <em>sisj</em>, <em>convertTo='11'</em>, <em>concat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.convert_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert single spin means and pairwise correlations between {0,1} and {-1,1} formulations.</p>
<p>si (ndarray)
sisj (ndarray)
convertTo (str,‘11’)</p>
<blockquote>
<div>‘11’ will convert {0,1} formulation to +/-1 and ‘01’ will convert +/-1 formulation to {0,1}</div></blockquote>
<dl class="docutils">
<dt>concat (bool=False)</dt>
<dd>If True, return concatenation of means and pairwise correlations.</dd>
</dl>
<dl class="docutils">
<dt>si</dt>
<dd>Converted to appropriate basis</dd>
<dt>sisj</dt>
<dd>converted to appropriate basis</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.convert_params">
<code class="descclassname">coniii.utils.</code><code class="descname">convert_params</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>convert_to='01'</em>, <em>concat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.convert_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Ising model fields and couplings from {0,1} basis to {-1,1} and vice versa.</p>
<p>h : ndarray
J : ndarray
convert_to : str</p>
<blockquote>
<div>‘01’ or ‘11’</div></blockquote>
<dl class="docutils">
<dt>concat <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>If True, return a vector concatenating fields and couplings.</dd>
</dl>
<p>h : ndarray
J : ndarray</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.define_ising_helper_functions">
<code class="descclassname">coniii.utils.</code><code class="descname">define_ising_helper_functions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.define_ising_helper_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions for plugging into solvers for +/-1 Ising model with fields h_i and couplings J_ij.</p>
<p>calc_e
calc_observables
mch_approximation</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.define_ising_helper_functions_sym">
<code class="descclassname">coniii.utils.</code><code class="descname">define_ising_helper_functions_sym</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.define_ising_helper_functions_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions for plugging into solvers for +/-1 Ising model with couplings J_ij and no fields.</p>
<p>calc_e
calc_observables
mch_approximation</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.define_pseudo_ising_helpers">
<code class="descclassname">coniii.utils.</code><code class="descname">define_pseudo_ising_helpers</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.define_pseudo_ising_helpers" title="Permalink to this definition">¶</a></dt>
<dd><p>Define helper functions for using Pseudo method on fully connected Ising model.</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>System size.</dd>
</dl>
<p>get_multipliers_r, calc_observables_r</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.ind_to_sub">
<code class="descclassname">coniii.utils.</code><code class="descname">ind_to_sub</code><a class="headerlink" href="#coniii.utils.ind_to_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert index from flattened upper triangular matrix to pair subindex.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Dimension size of square array.</dd>
<dt>ix <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Index to convert.</dd>
</dl>
<dl class="docutils">
<dt>subix <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>(i,j)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.ising_convert_params">
<code class="descclassname">coniii.utils.</code><code class="descname">ising_convert_params</code><span class="sig-paren">(</span><em>oparams</em>, <em>convert_to='01'</em>, <em>concat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.ising_convert_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Take set of Ising model parameters up to nth order interactions in either {0,1} or {-1,1} basis
and convert to other basis.</p>
<dl class="docutils">
<dt>oparams <span class="classifier-delimiter">:</span> <span class="classifier">tuple of lists</span></dt>
<dd>Tuple of lists of interactions between spins starting with the lowest order interactions. Each list
should consist of all interactions of that order such that the length of each list should be
binomial(n,i) for all i starting with i&gt;=1.</dd>
</dl>
<p>convert_to : str,‘01’
concat : bool,False</p>
<dl class="docutils">
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">tuple of lists or list</span></dt>
<dd>New parameters in order of lowest to highest order interactions to mean biases. Can all be
concatenated together if concat switch is True.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.k_corr">
<code class="descclassname">coniii.utils.</code><code class="descname">k_corr</code><span class="sig-paren">(</span><em>X</em>, <em>k</em>, <em>weights=None</em>, <em>exclude_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.k_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate kth order correlations of spins.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Dimensions (n_samples,n_dim).</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Order of correlation &lt;s_{i_1} * s_{i_2} * … * s_{i_k}&gt;.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray,None</span> <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>Calculate single and pairwise means given fractional weights for each state in
the data such that a state only appears with some weight, typically less than
one</dd>
<dt>exclude_empty <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>When using with {-1,1} basis, you can leave entries with 0 and those will not be counted for
any pair. If True, the weights option doesn’t do anything.</dd>
</dl>
<dl class="docutils">
<dt>kcorr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>&lt;s_{i_1} * s_{i_2} * … * s_{i_k}&gt;.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.multinomial">
<code class="descclassname">coniii.utils.</code><code class="descname">multinomial</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.multinomial" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.utils.pair_corr">
<code class="descclassname">coniii.utils.</code><code class="descname">pair_corr</code><span class="sig-paren">(</span><em>X</em>, <em>weights=None</em>, <em>concat=False</em>, <em>exclude_empty=False</em>, <em>subtract_mean=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.pair_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate averages and pairwise correlations of spins.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Dimensions (n_samples,n_dim).</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray,None</span> <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>Calculate single and pairwise means given fractional weights for each state in
the data such that a state only appears with some weight, typically less than
one</dd>
<dt>concat <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>Return means concatenated with the pairwise correlations into one array.</dd>
<dt>exclude_empty <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>When using with {-1,1} basis, you can leave entries with 0 and those will not be counted for
any pair. If True, the weights option doesn’t do anything.</dd>
<dt>subtract_mean <span class="classifier-delimiter">:</span> <span class="classifier">bool,False</span></dt>
<dd>If True, return pairwise correlations with product of individual means subtracted.</dd>
</dl>
<p>(si,sisj) or np.concatenate((si,sisj))</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.split_concat_params">
<code class="descclassname">coniii.utils.</code><code class="descname">split_concat_params</code><span class="sig-paren">(</span><em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.split_concat_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Split parameters for Ising model that have all been concatenated together into a single list into
separate lists. Assumes that the parameters are increasing in order of interaction and that all parameters
are present.</p>
<p>p : list-like</p>
<dl class="docutils">
<dt>splitp <span class="classifier-delimiter">:</span> <span class="classifier">list of list-like</span></dt>
<dd>Parameters increase in order (h, Jij, Kijk, … )</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.state_probs">
<code class="descclassname">coniii.utils.</code><code class="descname">state_probs</code><span class="sig-paren">(</span><em>v</em>, <em>allstates=None</em>, <em>weights=None</em>, <em>normalized=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.state_probs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get probability of unique states. There is an option to allow for weights counting of the words.</p>
<dl class="docutils">
<dt>states (ndarray)</dt>
<dd>(n_samples,n_dim)</dd>
</dl>
<p>weights (vector)
normalized (bool=True)</p>
<blockquote>
<div>Return probability distribution instead of frequency count</div></blockquote>
<dl class="docutils">
<dt>freq (ndarray)</dt>
<dd>Vector of the probabilities of each state</dd>
<dt>allstates (ndarray)</dt>
<dd>All unique states found in the data.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.sub_to_ind">
<code class="descclassname">coniii.utils.</code><code class="descname">sub_to_ind</code><a class="headerlink" href="#coniii.utils.sub_to_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pair of coordinates of a symmetric square array into consecutive index of flattened
upper triangle. This is slimmed down so it won’t throw errors like if i&gt;n or j&gt;n or if they’re
negative. Only checking for if the returned index is negative which could be problematic with
wrapped indices.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Dimension of square array</dd>
<dt>i,j <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>coordinates</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.unique_rows">
<code class="descclassname">coniii.utils.</code><code class="descname">unique_rows</code><span class="sig-paren">(</span><em>mat</em>, <em>return_inverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.unique_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique rows indices of a numeric numpy array.</p>
<p>mat (ndarray)
<a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs
return_inverse (bool)</p>
<blockquote>
<div>If True, return inverse that returns back indices of unique array that would return the
original array</div></blockquote>
<dl class="docutils">
<dt>u (ndarray)</dt>
<dd>Unique elements of matrix.</dd>
<dt>idx (ndarray)</dt>
<dd>row indices of given mat that will give unique array</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.unravel_index">
<code class="descclassname">coniii.utils.</code><code class="descname">unravel_index</code><span class="sig-paren">(</span><em>ijk</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.unravel_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Unravel multi-dimensional index to unidimensional index in flattened multi-dimensional analog of
an upper triangular array.</p>
<p>ijk : tuple
n : int</p>
<dl class="docutils">
<dt>ix <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Unraveled index.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.xbin_states">
<code class="descclassname">coniii.utils.</code><code class="descname">xbin_states</code><span class="sig-paren">(</span><em>n</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.xbin_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator for producing binary states.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spins</dd>
<dt>sym <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if true, return {-1,1} basis</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-coniii">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-coniii" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">ConIII</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">coniii package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coniii-custom-maxent-module">coniii.custom_maxent module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.enumerate">coniii.enumerate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.general_model_rmc">coniii.general_model_rmc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.ising">coniii.ising module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coniii-mc-hist-module">coniii.mc_hist module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.mean_field_ising">coniii.mean_field_ising module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.pseudo_inverse_ising">coniii.pseudo_inverse_ising module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.samplers">coniii.samplers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.solvers">coniii.solvers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.test_samplers">coniii.test_samplers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.test_solvers">coniii.test_solvers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.test_utils">coniii.test_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii.utils">coniii.utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-coniii">Module contents</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to ConIII’s documentation!</a></li>
      <li>Next: <a href="coniii.ising.html" title="next chapter">coniii.ising package</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Edward D. Lee, Bryan C. Daniels.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/coniii.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>