
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>coniii.utils module &#8212; ConIII 1.0.2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="coniii.samplers module" href="coniii.samplers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-coniii.utils">
<span id="coniii-utils-module"></span><h1>coniii.utils module<a class="headerlink" href="#module-coniii.utils" title="Permalink to this headline">¶</a></h1>
<dl class="attribute">
<dt id="coniii.utils.adj">
<code class="descclassname">coniii.utils.</code><code class="descname">adj</code><a class="headerlink" href="#coniii.utils.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return one-flip neighbors and a set of random neighbors. This is written to be used
with the solvers.MPF class. Use adj_sym() if symmetric spins in {-1,1} are needed.</p>
<p>NOTE: For random neighbors, there is no check to make sure neighbors don’t repeat but
this shouldn’t be a problem as long as state space is large enough.</p>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>State whose neighbors are found. One-dimensional vector of spins.</dd>
<dt>n_random_neighbors <span class="classifier-delimiter">:</span> <span class="classifier">int,0</span></dt>
<dd>If &gt;0, return this many random neighbors. Neighbors are just random states, but
they are called “neighbors” because of the terminology in MPF. They can provide
coupling from s to states that are very different, increasing the equilibration
rate.</dd>
</dl>
<dl class="docutils">
<dt>neighbors <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Each row is a neighbor. s.size + n_random_neighbors are returned.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.adj_sym">
<code class="descclassname">coniii.utils.</code><code class="descname">adj_sym</code><a class="headerlink" href="#coniii.utils.adj_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetric version of adj() where spins are in {-1,1}.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.base_repr">
<code class="descclassname">coniii.utils.</code><code class="descname">base_repr</code><a class="headerlink" href="#coniii.utils.base_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return decimal number in given base as list.</p>
<p>i : int
base : int</p>
<p>list</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.bin_states">
<code class="descclassname">coniii.utils.</code><code class="descname">bin_states</code><span class="sig-paren">(</span><em>n</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.bin_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all possible binary spin states.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of spins.</dd>
<dt>sym <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If true, return states in {-1,1} basis.</dd>
</dl>
<p>v : ndarray</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.calc_de">
<code class="descclassname">coniii.utils.</code><code class="descname">calc_de</code><span class="sig-paren">(</span><em>s</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.calc_de" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the derivative of the energy wrt parameters given the state and index of
the parameter. In this case, the parameters are the concatenated vector of {h_i,J_ij}.</p>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Two-dimensional vector of spins where each row is a state.</dd>
</dl>
<p>i : int</p>
<dl class="docutils">
<dt>dE <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Derivative of hamiltonian with respect to ith parameter, i.e. the corresponding
observable.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.calc_overlap">
<code class="descclassname">coniii.utils.</code><code class="descname">calc_overlap</code><span class="sig-paren">(</span><em>sample</em>, <em>ignore_zeros=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.calc_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;si_a si_b&gt; between all pairs of replicas a and b</p>
<p>sample
ignore_zeros (bool=False)</p>
<blockquote>
<div>Instead of normalizing by the number of spins, normalize by the minimum number of
nonzero spins.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.coarse_grain_with_func">
<code class="descclassname">coniii.utils.</code><code class="descname">coarse_grain_with_func</code><span class="sig-paren">(</span><em>X</em>, <em>n_times</em>, <em>sim_func</em>, <em>coarse_func</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.coarse_grain_with_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively coarse-grain X by combining pairs with the highest similarity. Both the
function to measure similarity and to implement the coarse-graining must be supplied.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Each col is a variable and each row is an observation (n_samples, n_system).</dd>
<dt>n_times <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of times to coarse grain.</dd>
<dt>sim_func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>Takes an array like X and returns a vector of ncol*(ncol-1)//2 pairwise
similarities.</dd>
<dt>coarse_func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>Takes a two col array and returns a single vector.</dd>
</dl>
<dl class="docutils">
<dt>ndarray</dt>
<dd>Coarse-grained version of X.</dd>
<dt>list of lists of ints </dt>
<dd>Each list specifies which columns of X have been coarse-grained into each col of
the coarse X.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.convert_corr">
<code class="descclassname">coniii.utils.</code><code class="descname">convert_corr</code><span class="sig-paren">(</span><em>si</em>, <em>sisj</em>, <em>convert_to</em>, <em>concat=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.convert_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert single spin means and pairwise correlations between {0,1} and {-1,1}
formulations.</p>
<dl class="docutils">
<dt>si <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Individual means.</dd>
<dt>sisj <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Pairwise correlations.</dd>
<dt>convert_to <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>‘11’ will convert {0,1} formulation to +/-1 and ‘01’ will convert +/-1 formulation
to {0,1}</dd>
<dt>concat <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, return concatenation of means and pairwise correlations.</dd>
</dl>
<dl class="docutils">
<dt>ndarray</dt>
<dd>Averages &lt;si&gt;. Converted to appropriate basis. Returns concatenated vector &lt;si&gt;
and &lt;sisj&gt; if concat is True.</dd>
<dt>ndarray, optional</dt>
<dd>Pairwise correlations &lt;si*sj&gt;. Converted to appropriate basis.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.convert_params">
<code class="descclassname">coniii.utils.</code><code class="descname">convert_params</code><span class="sig-paren">(</span><em>h</em>, <em>J</em>, <em>convert_to</em>, <em>concat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.convert_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Ising model fields and couplings from {0,1} basis to {-1,1} and vice versa.</p>
<dl class="docutils">
<dt>h <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Fields.</dd>
<dt>J <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Couplings.</dd>
<dt>convert_to <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Either ‘01’ or ‘11’.</dd>
<dt>concat <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, return a vector concatenating fields and couplings.</dd>
</dl>
<dl class="docutils">
<dt>ndarray</dt>
<dd>Mean bias h vector. Concatenated vector of h and J if concat is True.</dd>
<dt>ndarray, optional</dt>
<dd>Vector of J.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.define_ising_helper_functions">
<code class="descclassname">coniii.utils.</code><code class="descname">define_ising_helper_functions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.define_ising_helper_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions for plugging into solvers for +/-1 Ising model with fields h_i and
couplings J_ij.</p>
<dl class="docutils">
<dt>function</dt>
<dd>calc_e</dd>
<dt>function</dt>
<dd>calc_observables</dd>
<dt>function</dt>
<dd>mch_approximation</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.define_ising_helper_functions_sym">
<code class="descclassname">coniii.utils.</code><code class="descname">define_ising_helper_functions_sym</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.define_ising_helper_functions_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions for plugging into solvers for +/-1 Ising model with couplings J_ij and no
fields.</p>
<dl class="docutils">
<dt>function</dt>
<dd>calc_e</dd>
<dt>function</dt>
<dd>calc_observables</dd>
<dt>function</dt>
<dd>mch_approximation</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.define_pseudo_ising_helpers">
<code class="descclassname">coniii.utils.</code><code class="descname">define_pseudo_ising_helpers</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.define_pseudo_ising_helpers" title="Permalink to this definition">¶</a></dt>
<dd><p>Define helper functions for using Pseudo method on fully connected Ising model.</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>System size.</dd>
</dl>
<p>get_multipliers_r, calc_observables_r</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.ind_to_sub">
<code class="descclassname">coniii.utils.</code><code class="descname">ind_to_sub</code><a class="headerlink" href="#coniii.utils.ind_to_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert index from flattened upper triangular matrix to pair subindex.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Dimension size of square array.</dd>
<dt>ix <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Index to convert.</dd>
</dl>
<dl class="docutils">
<dt>subix <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>(i,j)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.ising_convert_params">
<code class="descclassname">coniii.utils.</code><code class="descname">ising_convert_params</code><span class="sig-paren">(</span><em>oparams</em>, <em>convert_to</em>, <em>concat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.ising_convert_params" title="Permalink to this definition">¶</a></dt>
<dd><p>General conversion of parameters from 01 to 11 basis.</p>
<p>Take set of Ising model parameters up to nth order interactions in either {0,1} or
{-1,1} basis and convert to other basis.</p>
<dl class="docutils">
<dt>oparams <span class="classifier-delimiter">:</span> <span class="classifier">tuple of lists</span></dt>
<dd>Tuple of lists of interactions between spins starting with the lowest order
interactions. Each list should consist of all interactions of that order such that
the length of each list should be binomial(n,i) for all i starting with i&gt;=1.</dd>
</dl>
<p>convert_to : str
concat : bool,False</p>
<dl class="docutils">
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">tuple of lists or list</span></dt>
<dd>New parameters in order of lowest to highest order interactions to mean biases.
Can all be concatenated together if concat switch is True.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.k_corr">
<code class="descclassname">coniii.utils.</code><code class="descname">k_corr</code><span class="sig-paren">(</span><em>X</em>, <em>k</em>, <em>weights=None</em>, <em>exclude_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.k_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate kth order correlations of spins.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Dimensions (n_samples, n_dim).</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Order of correlation function &lt;s_{i_1} * s_{i_2} * … * s_{i_k}&gt;.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, None</span> <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>Calculate single and pairwise means given fractional weights for each state in
the data such that a state only appears with some weight, typically less than
one.</dd>
<dt>exclude_empty <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>When using with {-1,1} basis, you can leave entries with 0 and those will not be
counted for any pair. If True, the weights option doesn’t do anything.</dd>
</dl>
<dl class="docutils">
<dt>ndarray</dt>
<dd>Kth order correlations &lt;s_{i_1} * s_{i_2} * … * s_{i_k}&gt;.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.multinomial">
<code class="descclassname">coniii.utils.</code><code class="descname">multinomial</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.multinomial" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="coniii.utils.pair_corr">
<code class="descclassname">coniii.utils.</code><code class="descname">pair_corr</code><span class="sig-paren">(</span><em>X</em>, <em>weights=None</em>, <em>concat=False</em>, <em>exclude_empty=False</em>, <em>subtract_mean=False</em>, <em>laplace_count=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.pair_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate averages and pairwise correlations of spins.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Dimensions (n_samples,n_dim).</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">float or np.ndarray or twople, None</span></dt>
<dd>If an array is passed, it must be the length of the data and each data point will
be given the corresponding weight. Otherwise, the two element tuple should contain
the normalization for each mean and each pairwise correlation, in that order. In
other words, the first array should be length {s_i} and the second length
{si*s_j}.</dd>
<dt>concat <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>Return means concatenated with the pairwise correlations into one array.</dd>
<dt>exclude_empty <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>When using with {-1,1} basis, you can leave entries with 0 and those will not be
counted for any pair. If True, the weights option doesn’t do anything.</dd>
<dt>subtract_mean <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, return pairwise correlations with product of individual means subtracted.</dd>
</dl>
<p>laplace_count :</p>
<dl class="docutils">
<dt>twople</dt>
<dd>(si,sisj) or np.concatenate((si,sisj))</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.split_concat_params">
<code class="descclassname">coniii.utils.</code><code class="descname">split_concat_params</code><span class="sig-paren">(</span><em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.split_concat_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Split parameters for Ising model that have all been concatenated together into a
single list into separate lists. Assumes that the parameters are increasing in order
of interaction and that all parameters are present.</p>
<p>p : list-like</p>
<dl class="docutils">
<dt>list of list-like</dt>
<dd>Parameters increasing in order: (h, Jij, Kijk, … ).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.state_probs">
<code class="descclassname">coniii.utils.</code><code class="descname">state_probs</code><span class="sig-paren">(</span><em>v</em>, <em>allstates=None</em>, <em>weights=None</em>, <em>normalized=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.state_probs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get probability of unique states. There is an option to allow for weights counting
of the words.</p>
<dl class="docutils">
<dt>states <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>(n_samples,n_dim)</dd>
</dl>
<p>allstates : ndarray, None
weights : vector, None
normalized : bool, True</p>
<blockquote>
<div>Return probability distribution instead of frequency count</div></blockquote>
<dl class="docutils">
<dt>ndarray</dt>
<dd>Vector of the probabilities of each state.</dd>
<dt>ndarray</dt>
<dd>All unique states found in the data. Each state is a row.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.sub_to_ind">
<code class="descclassname">coniii.utils.</code><code class="descname">sub_to_ind</code><a class="headerlink" href="#coniii.utils.sub_to_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pair of coordinates of a symmetric square array into consecutive index of
flattened upper triangle. This is slimmed down so it won’t throw errors like if i&gt;n or
j&gt;n or if they’re negative. Only checking for if the returned index is negative which
could be problematic with wrapped indices.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Dimension of square array</dd>
<dt>i,j <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>coordinates</dd>
</dl>
<p>int</p>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.unique_rows">
<code class="descclassname">coniii.utils.</code><code class="descname">unique_rows</code><span class="sig-paren">(</span><em>mat</em>, <em>return_inverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.unique_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique rows indices of a numeric numpy array.</p>
<p>mat : ndarray
return_inverse : bool</p>
<blockquote>
<div>If True, return inverse that returns back indices of unique array that would
return the original array</div></blockquote>
<dl class="docutils">
<dt>u <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Unique elements of matrix.</dd>
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>row indices of given mat that will give unique array</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.unravel_index">
<code class="descclassname">coniii.utils.</code><code class="descname">unravel_index</code><span class="sig-paren">(</span><em>ijk</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.unravel_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Unravel multi-dimensional index to flattened index but specifically for
multi-dimensional analog of an upper triangular array (lower triangle indices are not
counted).</p>
<dl class="docutils">
<dt>ijk <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Raveled index to unravel.</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>System size.</dd>
</dl>
<dl class="docutils">
<dt>ix <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Unraveled index.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.utils.xbin_states">
<code class="descclassname">coniii.utils.</code><code class="descname">xbin_states</code><span class="sig-paren">(</span><em>n</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.utils.xbin_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator for iterating through all possible binary states.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of spins.</dd>
<dt>sym <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If true, return states in {-1,1} basis.</dd>
</dl>
<p>generator</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.utils.xpotts_states">
<code class="descclassname">coniii.utils.</code><code class="descname">xpotts_states</code><a class="headerlink" href="#coniii.utils.xpotts_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator for iterating through all states for Potts model with k distinct states.
This is a faster version of calling xbin_states(n, False) except with strings returned
as elements instead of integers.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of spins.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of distinct states. These are labeled by integers starting from 0 and must
be &lt;=36.</dd>
</dl>
<p>generator</p>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ConIII</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="coniii.enumerate.html">coniii.enumerate module</a></li>
<li class="toctree-l1"><a class="reference internal" href="coniii.solvers.html">coniii.solvers module</a></li>
<li class="toctree-l1"><a class="reference internal" href="coniii.samplers.html">coniii.samplers module</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">coniii.utils module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="coniii.samplers.html" title="previous chapter">coniii.samplers module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Edward D. Lee, Bryan C. Daniels.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/coniii_rst/coniii.utils.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>