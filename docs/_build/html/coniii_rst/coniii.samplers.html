
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>coniii.samplers module &#8212; ConIII 1.0.2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="coniii.utils module" href="coniii.utils.html" />
    <link rel="prev" title="coniii.solvers module" href="coniii.solvers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-coniii.samplers">
<span id="coniii-samplers-module"></span><h1>coniii.samplers module<a class="headerlink" href="#module-coniii.samplers" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="coniii.samplers.HamiltonianMC">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">HamiltonianMC</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>random_sample</em>, <em>grad_e=None</em>, <em>dt=0.01</em>, <em>leapfrogN=20</em>, <em>nCpus=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.HamiltonianMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.HamiltonianMC.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>nSamples</em>, <em>nBurn=100</em>, <em>fast=True</em>, <em>x0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.HamiltonianMC.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate nSamples from this Hamiltonian starting from random initial conditions from each sample.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.HamiltonianMC.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>x0</em>, <em>nBurn</em>, <em>saveHistory=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.HamiltonianMC.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single sample by MC sampling from this Hamiltonian. Slow method</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.Heisenberg3DSampler">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">Heisenberg3DSampler</code><span class="sig-paren">(</span><em>J</em>, <em>calc_e</em>, <em>random_sample</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<p>Simple MC Sampling from Heisenberg model with a lot of helpful functions.</p>
<p>generate_samples()
equilibrate_samples()
sample_metropolis()
sample_energy_min()</p>
<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.equilibrate_samples">
<code class="descname">equilibrate_samples</code><span class="sig-paren">(</span><em>samples</em>, <em>n_iters</em>, <em>method='mc'</em>, <em>nCpus=0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.equilibrate_samples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>nSamples</em>, <em>n_iters=100</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>sample_size : int</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.grad_E">
<code class="descname">grad_E</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.grad_E" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient wrt theta and phi.</p>
<dl class="docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>with dims (nSpins,2) with angles theta and phi</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_energy_min">
<code class="descname">sample_energy_min</code><span class="sig-paren">(</span><em>nFixed=0</em>, <em>rng=&lt;mtrand.RandomState object&gt;</em>, <em>initialState=None</em>, <em>method='powell'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_energy_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local energy minimum given state in angular form. Angular representation makes it easy to be
explicit about constraints on the vectors.</p>
<dl class="docutils">
<dt>initialState <span class="classifier-delimiter">:</span> <span class="classifier">ndarray,None</span></dt>
<dd>n_samples x n_features x 2</dd>
<dt>nFixed <span class="classifier-delimiter">:</span> <span class="classifier">int,0</span></dt>
<dd>Number of vectors that are fixed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_metropolis">
<code class="descname">sample_metropolis</code><span class="sig-paren">(</span><em>oldState</em>, <em>E0</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_metropolis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>State to perturb randomly.</dd>
<dt>energy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Energy of configuration.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_nearby_sample">
<code class="descname">sample_nearby_sample</code><span class="sig-paren">(</span><em>X</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_nearby_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly move given state around for new metropolis sample.
Question is whether it is more efficient to push only one of the many vectors around or all of them simultaneously.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Heisenberg3DSampler.sample_nearby_vector">
<code class="descname">sample_nearby_vector</code><span class="sig-paren">(</span><em>v</em>, <em>nSamples=1</em>, <em>otheta=None</em>, <em>ophi=None</em>, <em>sigma=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.sample_nearby_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample random vector that is nearby. It is important how you choose the width sigma.
NOTE: code might be simplified by using arctan2 instead of arctan</p>
<dl class="docutils">
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>xyz vector about which to sample random vectors</dd>
<dt>nSamples <span class="classifier-delimiter">:</span> <span class="classifier">int,1</span></dt>
<dd>number of random samples</dd>
<dt>otheta <span class="classifier-delimiter">:</span> <span class="classifier">float,None</span></dt>
<dd>polar angle for v</dd>
<dt>ophi <span class="classifier-delimiter">:</span> <span class="classifier">float,None</span></dt>
<dd>azimuthal angle for v</dd>
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">float,.1</span></dt>
<dd>width of Gaussian about v</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="coniii.samplers.Heisenberg3DSampler.to_dict">
<em class="property">classmethod </em><code class="descname">to_dict</code><span class="sig-paren">(</span><em>data</em>, <em>names</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Heisenberg3DSampler.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function taking 3d array of of samples and arranging them into n x 3 arrays in a dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.Metropolis">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">Metropolis</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>n_cpus=None</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.Metropolis.generate_cond_samples">
<code class="descname">generate_cond_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>fixed_subset</em>, <em>burn_in=1000</em>, <em>n_cpus=None</em>, <em>initial_sample=None</em>, <em>systematic_iter=False</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.generate_cond_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples from conditional distribution (while a subset of the spins are held fixed).
Samples are generated in parallel.</p>
<p>NOTE: There is a bug with multiprocess where many calls to the parallel sampling routine in
a row leads to increasingly slow evaluation of the code.</p>
<p>sample_size : int
fixed_subset : list of duples</p>
<blockquote>
<div>Each duple is the index of the spin and the value to fix it at.  These should be ordered
by spin index.</div></blockquote>
<dl class="docutils">
<dt>burn_in <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Burn in.</dd>
<dt>n_cpus <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of cpus to use.</dd>
<dt>initial_sample <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Option to set initial random sample.</dd>
<dt>systematic_iter <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Iterate through spins systematically instead of choosing them randomly.</dd>
<dt>parallel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, use parallelized routine.</dd>
</dl>
<dl class="docutils">
<dt>ndarray</dt>
<dd>Samples from distribution.</dd>
<dt>ndarray</dt>
<dd>Energy of each sample.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Metropolis.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>n_iters=1000</em>, <em>systematic_iter=False</em>, <em>saveHistory=False</em>, <em>initial_sample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Metropolis samples using a for loop.</p>
<dl class="docutils">
<dt>sample_size <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of samples.</dd>
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int, 1000</span></dt>
<dd>Number of iterations to run the sampler floor.</dd>
<dt>systematic_iter <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, iterate through each element of system by increment index by one.</dd>
<dt>saveHistory <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, also save the energy of each sample at each sampling step.</dd>
<dt>initial_sample <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, None</span></dt>
<dd>Start with this sample (i.e. to avoid warming up). Otherwise, self._samples is the initial sample.</dd>
</dl>
<dl class="docutils">
<dt>ndarray, optional</dt>
<dd>Saved array of energies at each sampling step.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Metropolis.generate_samples_parallel">
<code class="descname">generate_samples_parallel</code><span class="sig-paren">(</span><em>sample_size</em>, <em>n_iters=1000</em>, <em>initial_sample=None</em>, <em>systematic_iter=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.generate_samples_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples in parallel. Each replica in self._samples runs on its own thread and a 
sample is generated every n_iters.</p>
<dl class="docutils">
<dt>sample_size <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of samples.</dd>
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int, 1000</span></dt>
<dd>Number of iterations between taking a random sample.</dd>
<dt>initial_sample <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, None</span></dt>
<dd>Starting set of replicas otherwise self._samples is used.</dd>
<dt>systematic_iter <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, iterate through spins systematically instead of choosing them randomly.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Metropolis.sample_metropolis">
<code class="descname">sample_metropolis</code><span class="sig-paren">(</span><em>sample0</em>, <em>E0</em>, <em>rng=None</em>, <em>flip_site=None</em>, <em>calc_e=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Metropolis.sample_metropolis" title="Permalink to this definition">¶</a></dt>
<dd><p>Metropolis sampling given an arbitrary sampling function.</p>
<dl class="docutils">
<dt>sample0 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Sample to start with. Passed by ref and changed.</dd>
<dt>E0 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Initial energy of state.</dd>
<dt>rng <span class="classifier-delimiter">:</span> <span class="classifier">np.random.RandomState</span></dt>
<dd>Random number generator.</dd>
<dt>flip_site <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Site to flip.</dd>
<dt>calc_e <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>If another function to calculate energy should be used</dd>
</dl>
<dl class="docutils">
<dt>float</dt>
<dd>delta energy.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.ParallelTempering">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">ParallelTempering</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>n_replicas</em>, <em>Tbds=(1.0</em>, <em>3.0)</em>, <em>sample_size=1000</em>, <em>replica_burnin=None</em>, <em>rep_ex_burnin=None</em>, <em>n_cpus=None</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.ParallelTempering.burn_and_exchange">
<code class="descname">burn_and_exchange</code><span class="sig-paren">(</span><em>pool</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.burn_and_exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>pool : mp.multiprocess.Pool</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.burn_in_replicas">
<code class="descname">burn_in_replicas</code><span class="sig-paren">(</span><em>pool=None</em>, <em>close_pool=True</em>, <em>n_iters=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.burn_in_replicas" title="Permalink to this definition">¶</a></dt>
<dd><p>Run each replica separately.</p>
<p>pool : multiprocess.Pool, None
close_pool : bool, True</p>
<blockquote>
<div>If True, call pool.close() at end.</div></blockquote>
<dl class="docutils">
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int, None</span></dt>
<dd>Default value is self.replicaBurnin.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>save_exchange_trajectory=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Burn in, run replica exchange simulation, then sample.</p>
<dl class="docutils">
<dt>sample_size <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of samples to take for each replica.</dd>
<dt>save_exchange_trajectory <span class="classifier-delimiter">:</span> <span class="classifier">bool, False</span></dt>
<dd>If True, keep track of the location of each replica in beta space and return the history.</dd>
</dl>
<dl class="docutils">
<dt>ndarray, optional</dt>
<dd>Trajectory of each replica through beta space. Each row is tells where each index is located in
beta space.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="coniii.samplers.ParallelTempering.initialize_beta">
<em class="property">static </em><code class="descname">initialize_beta</code><span class="sig-paren">(</span><em>b0</em>, <em>b1</em>, <em>n_replicas</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.initialize_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Use linear interpolation of temperature range.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="coniii.samplers.ParallelTempering.iterate_beta">
<em class="property">static </em><code class="descname">iterate_beta</code><span class="sig-paren">(</span><em>beta</em>, <em>acceptance_ratio</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.iterate_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply algorithm from Hukushima but reversed to maintain one replica at T=1.</p>
<dl class="docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Inverse temperature.</dd>
<dt>acceptance_ratio <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Estimate of acceptance ratio.</dd>
</dl>
<dl class="docutils">
<dt>ndarray</dt>
<dd>New beta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.optimize_beta">
<code class="descname">optimize_beta</code><span class="sig-paren">(</span><em>n_samples</em>, <em>n_iters</em>, <em>tol=0.01</em>, <em>max_iter=10</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.optimize_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Find suitable temperature range for replicas. Sets self.beta.</p>
<dl class="docutils">
<dt>n_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of samples to use to estimate acceptance ratio. Acceptance ratio is estimated as the
average of these samples.</dd>
<dt>n_iters <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of sampling iterations for each replica.</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float, .1</span></dt>
<dd>Average change in beta to reach before stopping.</dd>
<dt>max_iter <span class="classifier-delimiter">:</span> <span class="classifier">int, 10</span></dt>
<dd>Number of times to iterate algorithm for beta. Each iteration involves sampling from replicas.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.setup_replicas">
<code class="descname">setup_replicas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.setup_replicas" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a set of replicas at different temperatures using the Metropolis algorithm and optimize the
temperatures. Replicas are burned in and ready to sample.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.ParallelTempering.update_replica_parameters">
<code class="descname">update_replica_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.ParallelTempering.update_replica_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update parameters for each replica. Remember that the parameters include the factor of beta.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.SWIsing">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">SWIsing</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>calc_e</em>, <em>nCpus=None</em>, <em>rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.SWIsing.generate_sample">
<code class="descname">generate_sample</code><span class="sig-paren">(</span><em>n_samples</em>, <em>n_iters</em>, <em>initial_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.generate_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>n_samples
n_iters
initial_state : ndarray,None</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.generate_sample_parallel">
<code class="descname">generate_sample_parallel</code><span class="sig-paren">(</span><em>n_samples</em>, <em>n_iters</em>, <em>initial_state=None</em>, <em>n_cpus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.generate_sample_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>n_samples
n_iters
initial_state : ndarray,None</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.get_clusters">
<code class="descname">get_clusters</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.get_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a random sample of clusters.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.one_step">
<code class="descname">one_step</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.one_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.print_cluster_size">
<code class="descname">print_cluster_size</code><span class="sig-paren">(</span><em>n_iters</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.print_cluster_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="coniii.samplers.SWIsing.randomly_flip_clusters">
<code class="descname">randomly_flip_clusters</code><span class="sig-paren">(</span><em>state</em>, <em>clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.SWIsing.randomly_flip_clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.Sampler">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">Sampler</code><span class="sig-paren">(</span><em>n</em>, <em>theta</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for MCMC sampling.</p>
<dl class="method">
<dt id="coniii.samplers.Sampler.generate_samples">
<code class="descname">generate_samples</code><span class="sig-paren">(</span><em>sample_size</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.generate_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>sample_size : int</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Sampler.generate_samples_parallel">
<code class="descname">generate_samples_parallel</code><span class="sig-paren">(</span><em>sample_size</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.generate_samples_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>sample_size : int</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Sampler.sample_metropolis">
<code class="descname">sample_metropolis</code><span class="sig-paren">(</span><em>s</em>, <em>energy</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.sample_metropolis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>State to perturb randomly.</dd>
<dt>energy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Energy of configuration.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.Sampler.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>new_parameters</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.Sampler.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="coniii.samplers.WolffIsing">
<em class="property">class </em><code class="descclassname">coniii.samplers.</code><code class="descname">WolffIsing</code><span class="sig-paren">(</span><em>J</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#coniii.samplers.Sampler" title="coniii.samplers.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">coniii.samplers.Sampler</span></code></a></p>
<dl class="method">
<dt id="coniii.samplers.WolffIsing.build_cluster">
<code class="descname">build_cluster</code><span class="sig-paren">(</span><em>state</em>, <em>initialsite</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.build_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Grow cluster from initial site.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.find_neighbors">
<code class="descname">find_neighbors</code><span class="sig-paren">(</span><em>state</em>, <em>site</em>, <em>alreadyMarked</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.find_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return neighbors of given site that need to be visited excluding sites that have already been visited.
This is the implementation of the Wolff algorithm for finding neighbors such that detailed balance is
satisfied. I have modified to include random fields such tha the probability of adding a neighbors
depends both on its coupling with the current site and the neighbor’s magnetic field.</p>
<p>state
site
alreadyMarked</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.generate_sample">
<code class="descname">generate_sample</code><span class="sig-paren">(</span><em>samplesize</em>, <em>n_iters</em>, <em>initialSample=None</em>, <em>save_history=False</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.generate_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples by starting from random initial states.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.generate_sample_parallel">
<code class="descname">generate_sample_parallel</code><span class="sig-paren">(</span><em>samplesize</em>, <em>n_iters</em>, <em>initialSample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.generate_sample_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples by starting from random or given initial states.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.one_step">
<code class="descname">one_step</code><span class="sig-paren">(</span><em>state</em>, <em>initialsite=None</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.one_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the Wolff algorithm that involves finding a cluster and possibly flipping it.</p>
</dd></dl>

<dl class="method">
<dt id="coniii.samplers.WolffIsing.update_parameters">
<code class="descname">update_parameters</code><span class="sig-paren">(</span><em>J</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.WolffIsing.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.calc_e">
<code class="descclassname">coniii.samplers.</code><code class="descname">calc_e</code><a class="headerlink" href="#coniii.samplers.calc_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Heisenberg model.</p>
<dl class="docutils">
<dt>theta <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>List of couplings Jij</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>List of angles (theta_0,phi_0,theta_1,phi_1,…,theta_n,phi_n)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="coniii.samplers.check_e_logp">
<code class="descclassname">coniii.samplers.</code><code class="descname">check_e_logp</code><span class="sig-paren">(</span><em>sample</em>, <em>calc_e</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.check_e_logp" title="Permalink to this definition">¶</a></dt>
<dd><p>Boltzmann type model with discrete state space should have E propto -logP. Calculate these quantities for
comparison.</p>
<p>sample
calc_e</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.cross">
<code class="descclassname">coniii.samplers.</code><code class="descname">cross</code><a class="headerlink" href="#coniii.samplers.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cross product of two 3d vectors.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.cross_">
<code class="descclassname">coniii.samplers.</code><code class="descname">cross_</code><a class="headerlink" href="#coniii.samplers.cross_" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cross product of two 3d vectors.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.grad_e">
<code class="descclassname">coniii.samplers.</code><code class="descname">grad_e</code><a class="headerlink" href="#coniii.samplers.grad_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivatives wrt the angles of the spins.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.grad_e_theta">
<code class="descclassname">coniii.samplers.</code><code class="descname">grad_e_theta</code><a class="headerlink" href="#coniii.samplers.grad_e_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivatives wrt the couplings theta.</p>
</dd></dl>

<dl class="function">
<dt id="coniii.samplers.iter_cluster">
<code class="descclassname">coniii.samplers.</code><code class="descname">iter_cluster</code><span class="sig-paren">(</span><em>adj</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.iter_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Cycle through all spins to get clusters.</p>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.iterate_neighbors">
<code class="descclassname">coniii.samplers.</code><code class="descname">iterate_neighbors</code><a class="headerlink" href="#coniii.samplers.iterate_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all neighbors of a particular site and see if a bond should be formed between them.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>System size.</dd>
<dt>ix <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of bool</span></dt>
<dd>Indices of sites that have already been visited.</dd>
<dt>expdJ <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>np.exp( -2*state[:,None]*state[None,:]*J )</dd>
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of random numbers.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.jit_sample">
<code class="descclassname">coniii.samplers.</code><code class="descname">jit_sample</code><a class="headerlink" href="#coniii.samplers.jit_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single sample by MC sampling from this Hamiltonian.</p>
<dl class="docutils">
<dt>theta <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Parameters</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Sample</dd>
</dl>
<p>nBurn : int
dt : float
leapfrogN : int
randNormal : ndarray</p>
<blockquote>
<div>nBurn x ndim</div></blockquote>
<dl class="docutils">
<dt>randUnif <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>nBurn</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.jit_sample_nearby_vector">
<code class="descclassname">coniii.samplers.</code><code class="descname">jit_sample_nearby_vector</code><a class="headerlink" href="#coniii.samplers.jit_sample_nearby_vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.pairwise_prod">
<code class="descclassname">coniii.samplers.</code><code class="descname">pairwise_prod</code><a class="headerlink" href="#coniii.samplers.pairwise_prod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="coniii.samplers.sample_bonds">
<code class="descclassname">coniii.samplers.</code><code class="descname">sample_bonds</code><a class="headerlink" href="#coniii.samplers.sample_bonds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Probability of bond formation.</dd>
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Random numbers.</dd>
</dl>
<p>state
J</p>
</dd></dl>

<dl class="function">
<dt id="coniii.samplers.spec_cluster">
<code class="descclassname">coniii.samplers.</code><code class="descname">spec_cluster</code><span class="sig-paren">(</span><em>L</em>, <em>exact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#coniii.samplers.spec_cluster" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>L <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Graph Laplacian</dd>
</dl>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ConIII</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="coniii.enumerate.html">coniii.enumerate module</a></li>
<li class="toctree-l1"><a class="reference internal" href="coniii.solvers.html">coniii.solvers module</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">coniii.samplers module</a></li>
<li class="toctree-l1"><a class="reference internal" href="coniii.utils.html">coniii.utils module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="coniii.solvers.html" title="previous chapter">coniii.solvers module</a></li>
      <li>Next: <a href="coniii.utils.html" title="next chapter">coniii.utils module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Edward D. Lee, Bryan C. Daniels.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/coniii_rst/coniii.samplers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>